<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Golang内存管理和垃圾回收 | 冲和</title><meta name=keywords content="go 内存管理,go gc"><meta name=description content="前言 网上有很多讲 go gc 的文章，但大多讲的不明不白， 一些突然出现的术语更是不知从何而起，导致看过一些文章后对 gc 依旧云里雾里。 好在最近在公众号看到了一篇文章，我觉得写的很赞， 起码解答了那些突然出现的术语是什么。
我决定把它搬运到这里，手写一遍记忆更加深刻。 接下来是对原文的默写，忘了就直接抄写。
原文中会贴出一些 go 的源代码，我本地 go 版本是 1.18.2，对照看的时候会有些出入， 出入的地方我就改贴上我本地的 go 源代码。 所有图片都来源于原文，原文地址在最下面参考文献中列出。 默写加抄写 本文以 go 内存管理为切入点，再到 go 垃圾回收，系统的讲解了 go 自动内存管理系统的设计和原理。
一、TCMalloc go 的内存管理借鉴了 TCMalloc 的设计思想，TCMalloc 全称 Thread-Caching Malloc， 是 google 开发的内存分配器，为了方便理解 go 的内存管理，有必要先熟悉下 TCMalloc。
(一) Page 操作系统对内存的管理以页为单位，TCMalloc 也是这样， 只不过 TCMalloc 里的 Page 大小与操作系统里的大小不一定相等，是倍数的关系。
(二) Span 一组连续的 Page 称为 Span，比如可以有 4 个页大小的 Span，也可以有 8 个页大小的 Span。 Span 比 Page 高一个层级，是为了方便管理一定大小的内存区域， Span 是 TCMalloc 中内存管理的基本单位。"><meta name=author content="冲和"><link rel=canonical href=https://theone-daxia.github.io/blog/code/go/gc/><link crossorigin=anonymous href=/assets/css/stylesheet.min.6f60056d44d3f7eb69a4bc6c332b59960f3a995802bded244750232f33713c49.css integrity="sha256-b2AFbUTT9+tppLxsMytZlg86mVgCve0kR1AjLzNxPEk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://theone-daxia.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://theone-daxia.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://theone-daxia.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://theone-daxia.github.io/apple-touch-icon.png><link rel=mask-icon href=https://theone-daxia.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.107.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-YBNN92PXEM"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-YBNN92PXEM",{anonymize_ip:!1})}</script><meta property="og:title" content="Golang内存管理和垃圾回收"><meta property="og:description" content="前言 网上有很多讲 go gc 的文章，但大多讲的不明不白， 一些突然出现的术语更是不知从何而起，导致看过一些文章后对 gc 依旧云里雾里。 好在最近在公众号看到了一篇文章，我觉得写的很赞， 起码解答了那些突然出现的术语是什么。
我决定把它搬运到这里，手写一遍记忆更加深刻。 接下来是对原文的默写，忘了就直接抄写。
原文中会贴出一些 go 的源代码，我本地 go 版本是 1.18.2，对照看的时候会有些出入， 出入的地方我就改贴上我本地的 go 源代码。 所有图片都来源于原文，原文地址在最下面参考文献中列出。 默写加抄写 本文以 go 内存管理为切入点，再到 go 垃圾回收，系统的讲解了 go 自动内存管理系统的设计和原理。
一、TCMalloc go 的内存管理借鉴了 TCMalloc 的设计思想，TCMalloc 全称 Thread-Caching Malloc， 是 google 开发的内存分配器，为了方便理解 go 的内存管理，有必要先熟悉下 TCMalloc。
(一) Page 操作系统对内存的管理以页为单位，TCMalloc 也是这样， 只不过 TCMalloc 里的 Page 大小与操作系统里的大小不一定相等，是倍数的关系。
(二) Span 一组连续的 Page 称为 Span，比如可以有 4 个页大小的 Span，也可以有 8 个页大小的 Span。 Span 比 Page 高一个层级，是为了方便管理一定大小的内存区域， Span 是 TCMalloc 中内存管理的基本单位。"><meta property="og:type" content="article"><meta property="og:url" content="https://theone-daxia.github.io/blog/code/go/gc/"><meta property="og:image" content="https://theone-daxia.github.io/papermod-cover.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-12-01T00:00:00+00:00"><meta property="article:modified_time" content="2022-12-01T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://theone-daxia.github.io/papermod-cover.png"><meta name=twitter:title content="Golang内存管理和垃圾回收"><meta name=twitter:description content="前言 网上有很多讲 go gc 的文章，但大多讲的不明不白， 一些突然出现的术语更是不知从何而起，导致看过一些文章后对 gc 依旧云里雾里。 好在最近在公众号看到了一篇文章，我觉得写的很赞， 起码解答了那些突然出现的术语是什么。
我决定把它搬运到这里，手写一遍记忆更加深刻。 接下来是对原文的默写，忘了就直接抄写。
原文中会贴出一些 go 的源代码，我本地 go 版本是 1.18.2，对照看的时候会有些出入， 出入的地方我就改贴上我本地的 go 源代码。 所有图片都来源于原文，原文地址在最下面参考文献中列出。 默写加抄写 本文以 go 内存管理为切入点，再到 go 垃圾回收，系统的讲解了 go 自动内存管理系统的设计和原理。
一、TCMalloc go 的内存管理借鉴了 TCMalloc 的设计思想，TCMalloc 全称 Thread-Caching Malloc， 是 google 开发的内存分配器，为了方便理解 go 的内存管理，有必要先熟悉下 TCMalloc。
(一) Page 操作系统对内存的管理以页为单位，TCMalloc 也是这样， 只不过 TCMalloc 里的 Page 大小与操作系统里的大小不一定相等，是倍数的关系。
(二) Span 一组连续的 Page 称为 Span，比如可以有 4 个页大小的 Span，也可以有 8 个页大小的 Span。 Span 比 Page 高一个层级，是为了方便管理一定大小的内存区域， Span 是 TCMalloc 中内存管理的基本单位。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://theone-daxia.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Golang内存管理和垃圾回收","item":"https://theone-daxia.github.io/blog/code/go/gc/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang内存管理和垃圾回收","name":"Golang内存管理和垃圾回收","description":"前言 网上有很多讲 go gc 的文章，但大多讲的不明不白， 一些突然出现的术语更是不知从何而起，导致看过一些文章后对 gc 依旧云里雾里。 好在最近在公众号看到了一篇文章，我觉得写的很赞， 起码解答了那些突然出现的术语是什么。\n我决定把它搬运到这里，手写一遍记忆更加深刻。 接下来是对原文的默写，忘了就直接抄写。\n原文中会贴出一些 go 的源代码，我本地 go 版本是 1.18.2，对照看的时候会有些出入， 出入的地方我就改贴上我本地的 go 源代码。 所有图片都来源于原文，原文地址在最下面参考文献中列出。 默写加抄写 本文以 go 内存管理为切入点，再到 go 垃圾回收，系统的讲解了 go 自动内存管理系统的设计和原理。\n一、TCMalloc go 的内存管理借鉴了 TCMalloc 的设计思想，TCMalloc 全称 Thread-Caching Malloc， 是 google 开发的内存分配器，为了方便理解 go 的内存管理，有必要先熟悉下 TCMalloc。\n(一) Page 操作系统对内存的管理以页为单位，TCMalloc 也是这样， 只不过 TCMalloc 里的 Page 大小与操作系统里的大小不一定相等，是倍数的关系。\n(二) Span 一组连续的 Page 称为 Span，比如可以有 4 个页大小的 Span，也可以有 8 个页大小的 Span。 Span 比 Page 高一个层级，是为了方便管理一定大小的内存区域， Span 是 TCMalloc 中内存管理的基本单位。","keywords":["go 内存管理","go gc"],"articleBody":"前言 网上有很多讲 go gc 的文章，但大多讲的不明不白， 一些突然出现的术语更是不知从何而起，导致看过一些文章后对 gc 依旧云里雾里。 好在最近在公众号看到了一篇文章，我觉得写的很赞， 起码解答了那些突然出现的术语是什么。\n我决定把它搬运到这里，手写一遍记忆更加深刻。 接下来是对原文的默写，忘了就直接抄写。\n原文中会贴出一些 go 的源代码，我本地 go 版本是 1.18.2，对照看的时候会有些出入， 出入的地方我就改贴上我本地的 go 源代码。 所有图片都来源于原文，原文地址在最下面参考文献中列出。 默写加抄写 本文以 go 内存管理为切入点，再到 go 垃圾回收，系统的讲解了 go 自动内存管理系统的设计和原理。\n一、TCMalloc go 的内存管理借鉴了 TCMalloc 的设计思想，TCMalloc 全称 Thread-Caching Malloc， 是 google 开发的内存分配器，为了方便理解 go 的内存管理，有必要先熟悉下 TCMalloc。\n(一) Page 操作系统对内存的管理以页为单位，TCMalloc 也是这样， 只不过 TCMalloc 里的 Page 大小与操作系统里的大小不一定相等，是倍数的关系。\n(二) Span 一组连续的 Page 称为 Span，比如可以有 4 个页大小的 Span，也可以有 8 个页大小的 Span。 Span 比 Page 高一个层级，是为了方便管理一定大小的内存区域， Span 是 TCMalloc 中内存管理的基本单位。\n(三) ThreadCache 每个线程各自的 Cache，一个 Cache 包含多个空闲的内存块链表， 同一个链表上的内存块大小相同，也可以说按内存块大小，给内存块分了个类， 这样可以根据申请的内存大小，快速从合适的链表上选择空闲内存块。 由于每个线程都有自己的 ThreadCache，所以 ThreadCache 的访问是无锁的。\n(四) CentralCache 是所有线程共享的缓存，也是保存的空闲内存块链表， 链表的数量和 ThreadCache 中链表的数量相同。 当 ThreadCache 内存块不足时，可以从 CentralCache 取， 当 ThreadCache 内存块多时，可以放回 CentralCache。 由于 CentralCache 是共享的，所以它的访问是要加锁的。\n(五) PageHeap PageHeap 是堆内存的抽象，存的也是若干链表，链表保存的是 Span， 当 CentralCache 没有内存时，会从 PageHeap 取， 把一个 Span 拆成若干内存块，添加到对应大小的链表中， 当 CentralCache 内存多时，会放回 PageHeap。\n(六) TCMalloc 对象分配 小对象直接从 ThreadCache 分配， 若 ThreadCache 不够，则从 CentralCache 中获取内存， 若 CentralCache 不够，则从 PageHeap 中获取内存； 大对象在 PageHeap 中选取合适的页组成 Span 用于存储数据。\n二、go 内存管理 go 内存管理架构取之 TCMalloc，不过在细节上有些出入， 先来看一张 go 内存管理架构图：\n(一) Page (二) Span (三) mcache (四) mcentral (五) mheap (六) 内存分配 三、垃圾回收 (一) 标记-清除 (二) 三色可达性分析 (三) gc 触发 (四) gc 过程 gcStart Mark Sweep 参考文献 超干货！彻底搞懂Golang内存管理和垃圾回收 ","wordCount":"177","inLanguage":"en","datePublished":"2022-12-01T00:00:00Z","dateModified":"2022-12-01T00:00:00Z","author":{"@type":"Person","name":"冲和"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://theone-daxia.github.io/blog/code/go/gc/"},"publisher":{"@type":"Organization","name":"冲和","logo":{"@type":"ImageObject","url":"https://theone-daxia.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://theone-daxia.github.io/ accesskey=h title="冲和 (Alt + H)">冲和</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://theone-daxia.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://theone-daxia.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://theone-daxia.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://theone-daxia.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://theone-daxia.github.io/follow_me title=关注我><span>关注我</span></a></li><li><a href=https://theone-daxia.github.io/blog/medical_beauty/project/ title=医美专区><span>医美专区</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://theone-daxia.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://theone-daxia.github.io/blog/>Blogs</a></div><h1 class=post-title>Golang内存管理和垃圾回收</h1><div class=post-meta><span title='2022-12-01 00:00:00 +0000 UTC'>December 1, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;冲和</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#%e9%bb%98%e5%86%99%e5%8a%a0%e6%8a%84%e5%86%99 aria-label=默写加抄写>默写加抄写</a><ul><li><a href=#%e4%b8%80tcmalloc aria-label=一、TCMalloc>一、TCMalloc</a><ul><li><a href=#%e4%b8%80-page aria-label="(一) Page">(一) Page</a></li><li><a href=#%e4%ba%8c-span aria-label="(二) Span">(二) Span</a></li><li><a href=#%e4%b8%89-threadcache aria-label="(三) ThreadCache">(三) ThreadCache</a></li><li><a href=#%e5%9b%9b-centralcache aria-label="(四) CentralCache">(四) CentralCache</a></li><li><a href=#%e4%ba%94-pageheap aria-label="(五) PageHeap">(五) PageHeap</a></li><li><a href=#%e5%85%ad-tcmalloc-%e5%af%b9%e8%b1%a1%e5%88%86%e9%85%8d aria-label="(六) TCMalloc 对象分配">(六) TCMalloc 对象分配</a></li></ul></li><li><a href=#%e4%ba%8cgo-%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86 aria-label="二、go 内存管理">二、go 内存管理</a><ul><li><a href=#%e4%b8%80-page-1 aria-label="(一) Page">(一) Page</a></li><li><a href=#%e4%ba%8c-span-1 aria-label="(二) Span">(二) Span</a></li><li><a href=#%e4%b8%89-mcache aria-label="(三) mcache">(三) mcache</a></li><li><a href=#%e5%9b%9b-mcentral aria-label="(四) mcentral">(四) mcentral</a></li><li><a href=#%e4%ba%94-mheap aria-label="(五) mheap">(五) mheap</a></li><li><a href=#%e5%85%ad-%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d aria-label="(六) 内存分配">(六) 内存分配</a></li></ul></li><li><a href=#%e4%b8%89%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6 aria-label=三、垃圾回收>三、垃圾回收</a><ul><li><a href=#%e4%b8%80-%e6%a0%87%e8%ae%b0-%e6%b8%85%e9%99%a4 aria-label="(一) 标记-清除">(一) 标记-清除</a></li><li><a href=#%e4%ba%8c-%e4%b8%89%e8%89%b2%e5%8f%af%e8%be%be%e6%80%a7%e5%88%86%e6%9e%90 aria-label="(二) 三色可达性分析">(二) 三色可达性分析</a></li><li><a href=#%e4%b8%89-gc-%e8%a7%a6%e5%8f%91 aria-label="(三) gc 触发">(三) gc 触发</a></li><li><a href=#%e5%9b%9b-gc-%e8%bf%87%e7%a8%8b aria-label="(四) gc 过程">(四) gc 过程</a></li></ul></li></ul></li><li><a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae aria-label=参考文献>参考文献</a></li></ul></div></details></div><div class=post-content><h1 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h1><p>网上有很多讲 go gc 的文章，但大多讲的不明不白，
一些突然出现的术语更是不知从何而起，导致看过一些文章后对 gc 依旧云里雾里。
好在最近在公众号看到了一篇文章，我觉得写的很赞，
起码解答了那些突然出现的术语是什么。</p><p>我决定把它搬运到这里，手写一遍记忆更加深刻。
接下来是对原文的默写，忘了就直接抄写。</p><ul><li>原文中会贴出一些 go 的源代码，我本地 go 版本是 1.18.2，对照看的时候会有些出入，
出入的地方我就改贴上我本地的 go 源代码。</li><li>所有图片都来源于原文，原文地址在最下面参考文献中列出。</li></ul><h1 id=默写加抄写>默写加抄写<a hidden class=anchor aria-hidden=true href=#默写加抄写>#</a></h1><p>本文以 go 内存管理为切入点，再到 go 垃圾回收，系统的讲解了 go 自动内存管理系统的设计和原理。</p><h2 id=一tcmalloc>一、TCMalloc<a hidden class=anchor aria-hidden=true href=#一tcmalloc>#</a></h2><p>go 的内存管理借鉴了 TCMalloc 的设计思想，TCMalloc 全称 Thread-Caching Malloc，
是 google 开发的内存分配器，为了方便理解 go 的内存管理，有必要先熟悉下 TCMalloc。</p><img src=/img/code/go-gc/TCMalloc.png><p><img loading=lazy src=/img/code/go-gc/TCMalloc.png alt=TCMalloc></p><h3 id=一-page>(一) Page<a hidden class=anchor aria-hidden=true href=#一-page>#</a></h3><p>操作系统对内存的管理以页为单位，TCMalloc 也是这样，
只不过 TCMalloc 里的 Page 大小与操作系统里的大小不一定相等，是倍数的关系。</p><h3 id=二-span>(二) Span<a hidden class=anchor aria-hidden=true href=#二-span>#</a></h3><p>一组连续的 Page 称为 Span，比如可以有 4 个页大小的 Span，也可以有 8 个页大小的 Span。
Span 比 Page 高一个层级，是为了方便管理一定大小的内存区域，
Span 是 TCMalloc 中内存管理的基本单位。</p><h3 id=三-threadcache>(三) ThreadCache<a hidden class=anchor aria-hidden=true href=#三-threadcache>#</a></h3><p>每个线程各自的 Cache，一个 Cache 包含多个空闲的内存块链表，
同一个链表上的内存块大小相同，也可以说按内存块大小，给内存块分了个类，
这样可以根据申请的内存大小，快速从合适的链表上选择空闲内存块。
由于每个线程都有自己的 ThreadCache，所以 ThreadCache 的访问是无锁的。</p><h3 id=四-centralcache>(四) CentralCache<a hidden class=anchor aria-hidden=true href=#四-centralcache>#</a></h3><p>是所有线程共享的缓存，也是保存的空闲内存块链表，
链表的数量和 ThreadCache 中链表的数量相同。
当 ThreadCache 内存块不足时，可以从 CentralCache 取，
当 ThreadCache 内存块多时，可以放回 CentralCache。
由于 CentralCache 是共享的，所以它的访问是要加锁的。</p><h3 id=五-pageheap>(五) PageHeap<a hidden class=anchor aria-hidden=true href=#五-pageheap>#</a></h3><p>PageHeap 是堆内存的抽象，存的也是若干链表，链表保存的是 Span，
当 CentralCache 没有内存时，会从 PageHeap 取，
把一个 Span 拆成若干内存块，添加到对应大小的链表中，
当 CentralCache 内存多时，会放回 PageHeap。</p><h3 id=六-tcmalloc-对象分配>(六) TCMalloc 对象分配<a hidden class=anchor aria-hidden=true href=#六-tcmalloc-对象分配>#</a></h3><p>小对象直接从 ThreadCache 分配，
若 ThreadCache 不够，则从 CentralCache 中获取内存，
若 CentralCache 不够，则从 PageHeap 中获取内存；
大对象在 PageHeap 中选取合适的页组成 Span 用于存储数据。</p><h2 id=二go-内存管理>二、go 内存管理<a hidden class=anchor aria-hidden=true href=#二go-内存管理>#</a></h2><p>go 内存管理架构取之 TCMalloc，不过在细节上有些出入，
先来看一张 go 内存管理架构图：</p><p><img loading=lazy src=/img/code/go-gc/go-memory-manage.png alt="go 内存管理"></p><h3 id=一-page-1>(一) Page<a hidden class=anchor aria-hidden=true href=#一-page-1>#</a></h3><h3 id=二-span-1>(二) Span<a hidden class=anchor aria-hidden=true href=#二-span-1>#</a></h3><h3 id=三-mcache>(三) mcache<a hidden class=anchor aria-hidden=true href=#三-mcache>#</a></h3><h3 id=四-mcentral>(四) mcentral<a hidden class=anchor aria-hidden=true href=#四-mcentral>#</a></h3><h3 id=五-mheap>(五) mheap<a hidden class=anchor aria-hidden=true href=#五-mheap>#</a></h3><h3 id=六-内存分配>(六) 内存分配<a hidden class=anchor aria-hidden=true href=#六-内存分配>#</a></h3><h2 id=三垃圾回收>三、垃圾回收<a hidden class=anchor aria-hidden=true href=#三垃圾回收>#</a></h2><h3 id=一-标记-清除>(一) 标记-清除<a hidden class=anchor aria-hidden=true href=#一-标记-清除>#</a></h3><h3 id=二-三色可达性分析>(二) 三色可达性分析<a hidden class=anchor aria-hidden=true href=#二-三色可达性分析>#</a></h3><h3 id=三-gc-触发>(三) gc 触发<a hidden class=anchor aria-hidden=true href=#三-gc-触发>#</a></h3><h3 id=四-gc-过程>(四) gc 过程<a hidden class=anchor aria-hidden=true href=#四-gc-过程>#</a></h3><ul><li>gcStart</li><li>Mark</li><li>Sweep</li></ul><h1 id=参考文献>参考文献<a hidden class=anchor aria-hidden=true href=#参考文献>#</a></h1><ul><li><a href=https://mp.weixin.qq.com/s/7Yjk9oeOPSm1h1SEnNh13A>超干货！彻底搞懂Golang内存管理和垃圾回收</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://theone-daxia.github.io/tags/go-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/>go 内存管理</a></li><li><a href=https://theone-daxia.github.io/tags/go-gc/>go gc</a></li></ul><nav class=paginav><a class=prev href=https://theone-daxia.github.io/blog/code/github/clone-private/><span class=title>« Prev Page</span><br><span>github 克隆自己的私有仓库</span></a>
<a class=next href=https://theone-daxia.github.io/blog/code/go/recursive-mutex/><span class=title>Next Page »</span><br><span>go实现可重入锁</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://theone-daxia.github.io/>冲和</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>