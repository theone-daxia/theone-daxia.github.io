[{"content":"单表建议存放多少数据？ 在主键索引上，用户记录是按页（数据页）存放在叶子节点，索引也是按页（索引页）存放在非叶子节点。 索引页的内容是 id 和页号地址。 id：对应页中最小记录的 id 值。 页号地址：地址是指向对应页的指针。 B+ 树是一个多叉树，假设：\n非叶子节点内指向其他页的数量为 x。 叶子节点内容纳的数据行数为 y。 B+ 树的层数为 z。 整棵树存储的用户记录数量为 total。 则 total = x ^ (z-1) * y ，即 x 的 z-1 次方再乘以 y。\nx 是多少？ 数据页中，除了用户记录外，还有固定的几部分：\n文件头（38B） 页头（56B） 最小最大记录（26B） 页目录（不好精确） 文件尾（8B） 加起来就算作 1K 吧，整页是 16K，用来存数据的就是 15K。 在索引页中主要记录的是主键与页号，主键假设是 bigint（8B），页号是固定的（4B）， 那么索引页中一条数据是 12B，则 x = 15 * 1024 / 12 ≈ 1280。\ny 是多少？ 同 x，一页中有 15K 是用来存数据的，但是一行用户记录的大小影响因素有很多，比如字段数量、字段类型等。 每行数据所占空间越大，每页中存储的行数越少。\n这里先假设每行记录占 1K，则 y = 15。\nz 是多少？ 如果数高是 2 层，即 z = 2，则 total = 1280 ^ 1 * 15 = 19200。 如果数高是 3 层，即 z = 3，则 total = 1280 ^ 2 * 15 = 24576000，约 2.45kw。 如果是 4 层，除了查询的时候磁盘 IO 会增加，total 也都 300 多亿了，不合理。 所以 B+ 树的层级一般最多是 3 层。\n这里如果用户记录每行占用的空间是 5K，那单页能存 3 条数据， 则 total = 1280 ^ 2 * 3 = 4915200，近 500w。\n所以在层级相同的情况下，行数据所占大小不同，整表存储的最大数据量建议值也不同， 而且影响查询性能的还有很多其他的因素，比如数据库版本、服务器配置、sql 写法等。\n总结 每页大概有 15K 用来存储数据。 B+ 树中，叶子节点和非叶子节点的数据结构是一样的，区别在于叶子结点存放的是用户记录，非叶子节点存的是主键和页号。 单表最大行数建议值是 2kw，超过了可能会导致 B+ 树层级更高，影响查询性能。 参考 MySQL 单表不要超过 2000W 行，靠谱吗？ ","permalink":"https://theone-daxia.github.io/blog/code/mysql/2000w/","summary":"单表建议存放多少数据？ 在主键索引上，用户记录是按页（数据页）存放在叶子节点，索引也是按页（索引页）存放在非叶子节点。 索引页的内容是 id 和页号地址。 id：对应页中最小记录的 id 值。 页号地址：地址是指向对应页的指针。 B+ 树是一个多叉树，假设：\n非叶子节点内指向其他页的数量为 x。 叶子节点内容纳的数据行数为 y。 B+ 树的层数为 z。 整棵树存储的用户记录数量为 total。 则 total = x ^ (z-1) * y ，即 x 的 z-1 次方再乘以 y。\nx 是多少？ 数据页中，除了用户记录外，还有固定的几部分：\n文件头（38B） 页头（56B） 最小最大记录（26B） 页目录（不好精确） 文件尾（8B） 加起来就算作 1K 吧，整页是 16K，用来存数据的就是 15K。 在索引页中主要记录的是主键与页号，主键假设是 bigint（8B），页号是固定的（4B）， 那么索引页中一条数据是 12B，则 x = 15 * 1024 / 12 ≈ 1280。\ny 是多少？ 同 x，一页中有 15K 是用来存数据的，但是一行用户记录的大小影响因素有很多，比如字段数量、字段类型等。 每行数据所占空间越大，每页中存储的行数越少。\n这里先假设每行记录占 1K，则 y = 15。","title":"MySQL 单表不要超过 2000w 行？"},{"content":"InnoDB 是如何存储数据的？ InnoDB 的数据是按「数据页」为单位进行读写的。一页默认大小为 16KB。 意味着数据库一次最少从磁盘中读取 16KB 的数据到内存中，一次最少将内存中 16KB 的数据刷到磁盘中。\n数据页的结构 数据页的结构如下图： 每一部分的作用如下\n文件头：表示页的通用信息。 页头：表示页的状态信息。 最小最大记录：两个虚拟的伪记录，分别表示页中的最小和最大记录。 用户记录：存储行记录。 空闲空间：页中还没有使用的空间。 页目录：存储用户记录的相对位置，对记录起到索引的作用。 文件尾：校验页是否完整。 文件头中有两个指针，分别指向上一个数据页和下一个数据页，连起来的页相当于一个双向链表。 采用链表的结构，是让数据页之间不需要物理上连续，而是逻辑上连续。\n数据页中的用户记录是如何组织的？ 数据页中的用户记录按照主键顺序组成单向链表。 单向链表的特点就是插入、删除方便，但是查询效率不高，最差情况需要遍历完所有节点才能检索到数据。\n为了加快检索，就设计了页目录。页目录与用户记录的关系如下图： 页目录的创建过程如下：\n将所有的记录划分为几个组，包括最小最大记录，但不包括标记为已删除的记录。 每个组最后一条记录的头信息中存储该组一共有多少条记录，字段为 n_owned（上图中粉色字段）。 页目录用来存储每组最后一条记录的地址偏移量，称为槽（slot），每个槽相当于指向了每组的最后一条记录。 所以页目录就是由多个槽组成，槽相当于分组记录的索引。 每个分组的记录数不会很多，只有几条，因为 InnoDB 对每个分组中的记录数有如下规定：\n第一个分组中的记录只能有 1 条。 最后一个分组中的记录条数范围为 1～8 条。 其余分组中的记录条数范围为 4～8 条。 如何在数据页中查找数据？ 以上图为例，如何查找主键值为 11 的用户记录？\n因为用户记录是按照主键值从小到大排序的，所以槽也是从小到大排序的， 所以在数据页中查找记录可以用二分法，具体查找过程如下：\n二分找到槽中间位为 2，2号槽最大记录为 8，8 \u0026lt; 11，继续往后找。 二分找到槽中间位为 3，2号槽最大记录为 12，12 \u0026gt; 11，所以要找的记录在 3 号槽里。 再次找到槽 2，即主键值为 8 的记录，然后往后遍历，直到找到主键值为 11 的记录。 参考 从数据页的角度看 B+ 树 ","permalink":"https://theone-daxia.github.io/blog/code/mysql/data_page/","summary":"InnoDB 是如何存储数据的？ InnoDB 的数据是按「数据页」为单位进行读写的。一页默认大小为 16KB。 意味着数据库一次最少从磁盘中读取 16KB 的数据到内存中，一次最少将内存中 16KB 的数据刷到磁盘中。\n数据页的结构 数据页的结构如下图： 每一部分的作用如下\n文件头：表示页的通用信息。 页头：表示页的状态信息。 最小最大记录：两个虚拟的伪记录，分别表示页中的最小和最大记录。 用户记录：存储行记录。 空闲空间：页中还没有使用的空间。 页目录：存储用户记录的相对位置，对记录起到索引的作用。 文件尾：校验页是否完整。 文件头中有两个指针，分别指向上一个数据页和下一个数据页，连起来的页相当于一个双向链表。 采用链表的结构，是让数据页之间不需要物理上连续，而是逻辑上连续。\n数据页中的用户记录是如何组织的？ 数据页中的用户记录按照主键顺序组成单向链表。 单向链表的特点就是插入、删除方便，但是查询效率不高，最差情况需要遍历完所有节点才能检索到数据。\n为了加快检索，就设计了页目录。页目录与用户记录的关系如下图： 页目录的创建过程如下：\n将所有的记录划分为几个组，包括最小最大记录，但不包括标记为已删除的记录。 每个组最后一条记录的头信息中存储该组一共有多少条记录，字段为 n_owned（上图中粉色字段）。 页目录用来存储每组最后一条记录的地址偏移量，称为槽（slot），每个槽相当于指向了每组的最后一条记录。 所以页目录就是由多个槽组成，槽相当于分组记录的索引。 每个分组的记录数不会很多，只有几条，因为 InnoDB 对每个分组中的记录数有如下规定：\n第一个分组中的记录只能有 1 条。 最后一个分组中的记录条数范围为 1～8 条。 其余分组中的记录条数范围为 4～8 条。 如何在数据页中查找数据？ 以上图为例，如何查找主键值为 11 的用户记录？\n因为用户记录是按照主键值从小到大排序的，所以槽也是从小到大排序的， 所以在数据页中查找记录可以用二分法，具体查找过程如下：\n二分找到槽中间位为 2，2号槽最大记录为 8，8 \u0026lt; 11，继续往后找。 二分找到槽中间位为 3，2号槽最大记录为 12，12 \u0026gt; 11，所以要找的记录在 3 号槽里。 再次找到槽 2，即主键值为 8 的记录，然后往后遍历，直到找到主键值为 11 的记录。 参考 从数据页的角度看 B+ 树 ","title":"数据页"},{"content":"背景 需要定时同步订单数据，所以在阿里云轻量应用服务器上配置了 crontab， 发现并未生效，但是手动执行命令是可以的。\n问题 crontab -e 配置定时任务后，未生效。\n解决 怀疑是环境变量未获取到的原因， 就在定时任务前加了 source /etc/profile，至此解决。\n# 之前的配置 * * * * * cd xxx \u0026amp;\u0026amp; php artisan schedule:run \u0026gt;\u0026gt; /dev/null 2\u0026gt;\u0026amp;1 # 修改之后的配置 * * * * * source /etc/profile;cd xxx \u0026amp;\u0026amp; php artisan schedule:run \u0026gt;\u0026gt; /dev/null 2\u0026gt;\u0026amp;1 具体可参考这篇文章 【转载】Linux 中 Crontab 执行时的环境变量问题\n","permalink":"https://theone-daxia.github.io/blog/code/linux/crontab/","summary":"背景 需要定时同步订单数据，所以在阿里云轻量应用服务器上配置了 crontab， 发现并未生效，但是手动执行命令是可以的。\n问题 crontab -e 配置定时任务后，未生效。\n解决 怀疑是环境变量未获取到的原因， 就在定时任务前加了 source /etc/profile，至此解决。\n# 之前的配置 * * * * * cd xxx \u0026amp;\u0026amp; php artisan schedule:run \u0026gt;\u0026gt; /dev/null 2\u0026gt;\u0026amp;1 # 修改之后的配置 * * * * * source /etc/profile;cd xxx \u0026amp;\u0026amp; php artisan schedule:run \u0026gt;\u0026gt; /dev/null 2\u0026gt;\u0026amp;1 具体可参考这篇文章 【转载】Linux 中 Crontab 执行时的环境变量问题","title":"轻量应用服务器配置crontab后无效"},{"content":"单台服务器最大并发 TCP 连接数 如何标识一个 TCP 连接 TCP 连接四元组： {源IP，源端口，目的IP，目的端口}\n客户端最大 TCP 连接数 client 每次发起 TCP 连接请求时，除非绑定端口，通常会让系统选取一个空闲端口， 该端口是独占的，不能和其他 TCP 连接共享。TCP 协议端口用 16 bits 描述，所以 最多有 65536 个端口，又因为端口 0 有特殊含义，不能使用，所以客户端最大 TCP 连接数为 65535。\n服务端最大 TCP 连接数（理论上） server 通常固定监听某个本地端口。TCP 连接四元组中，只有源IP、源端口是变化的， 所以最大 TCP 连接数为：客户端IP数 x 客户端端口数，对 IPV4，不考虑地址分类等 因素，最大 TCP 连接数为: 2^32 * 2^16 = 2^48\n单台服务器上，服务端并发 TCP 连接数实际能有多少？ 2^48 是理论上单机最大连接数，实际环境中，受到机器资源、操作系统等的限制，最大 TCP 并发连接数远不能达到理论上限。在 Unix/Linux 系统下限制连接数的主要因素是 内存和允许打开的文件描述符个数。每个 TCP 连接都要占用一定内存，大概 15～20k， 每个 socket 就是一个文件描述符。\n影响一个 socket 占用内存的参数包括： rmem_max, wmem_max, tcp_rmem, tcp_wmem, tcp_mem 等。\nserver 端，通过增加内存、修改能打开的最大文件描述符个数等参数，单机最大并发 TCP 连接数 超过 10 万是没问题的。在实际应用中，对大规模的网络应用，还需要考虑 C10K 问题。\n文件句柄限制 全局限制 cat /proc/sys/fs/file-max 返回 181795，表示 Linux 最大打开文件描述符个数\ncat /proc/sys/fs/file-nr 返回 1760、0、181795，\n第一个表示已经分配的文件句柄数。 第二个表示已经分配但没有使用的文件句柄数。 第二个表示最大文件句柄数。 修改时可用 root 权限修改 /etc/sysctl.conf 文件\nfs.file-max = 1000000 net.ipv4.ip_conntrack_max = 1000000 net.ipv4.netfilter.ip_conntrack_max = 1000000 进程限制 执行 ulimit -n，输出 65535，说明一个进程最多能打开 65535 个文件， 所以采用默认这种默认配置的话，最多可以并发上千个 TCP 连接。\n临时修改\nulimit -n 1000000 （系统重启或用户退出后失效）\n重启后失效的修改\n编辑 /etc/security/limits.conf 文件，修改为：\n* soft nofile 1000000 * hard nofile 1000000 永久修改\n编辑 /etc/rc.local 文件，在其后添加如下内容：\nulimit -SHn 1000000 参考文献 详解Linux服务器最大tcp连接数 Linux下高并发socket最大连接数所受的各种限制 ","permalink":"https://theone-daxia.github.io/blog/code/linux/max-tcp-connect-count/","summary":"单台服务器最大并发 TCP 连接数 如何标识一个 TCP 连接 TCP 连接四元组： {源IP，源端口，目的IP，目的端口}\n客户端最大 TCP 连接数 client 每次发起 TCP 连接请求时，除非绑定端口，通常会让系统选取一个空闲端口， 该端口是独占的，不能和其他 TCP 连接共享。TCP 协议端口用 16 bits 描述，所以 最多有 65536 个端口，又因为端口 0 有特殊含义，不能使用，所以客户端最大 TCP 连接数为 65535。\n服务端最大 TCP 连接数（理论上） server 通常固定监听某个本地端口。TCP 连接四元组中，只有源IP、源端口是变化的， 所以最大 TCP 连接数为：客户端IP数 x 客户端端口数，对 IPV4，不考虑地址分类等 因素，最大 TCP 连接数为: 2^32 * 2^16 = 2^48\n单台服务器上，服务端并发 TCP 连接数实际能有多少？ 2^48 是理论上单机最大连接数，实际环境中，受到机器资源、操作系统等的限制，最大 TCP 并发连接数远不能达到理论上限。在 Unix/Linux 系统下限制连接数的主要因素是 内存和允许打开的文件描述符个数。每个 TCP 连接都要占用一定内存，大概 15～20k， 每个 socket 就是一个文件描述符。\n影响一个 socket 占用内存的参数包括： rmem_max, wmem_max, tcp_rmem, tcp_wmem, tcp_mem 等。","title":"Linux 服务器最大 TCP 连接数"},{"content":"namespace（隔离性） linux namespace 是一种 linux kernel 提供的资源隔离方案：\n系统可以为进程分配不同的 namespace。 保证不同的 namespace 资源独立分配、进程彼此隔离，即不同 namespace 下的进程互不干扰。 linux 内核代码中 namespace 的实现 进程数据结构 struct task_struct { ... /* namespaces */ struct nsproxy *nsproxy; ... } 这里 nsproxy 属性就表示这个进程所在的 namespace 的信息。\nnamespace 数据结构 struct nsproxy { atomic_t count; struct uts_namespace *uts_ns; struct ipc_namespace *ipc_ns; struct mnt_namespace *mnt_ns; struct pid_namespace *pid_ns_for_children; struct net *net_ns; } linux 对 namespace 的操作方法 clone\n在创建新进程的系统调用时，可以通过 flags 参数指定需要新建的 namespace 类型： // CLONE_NEWCGROUP, CLONE_NEWIPC, CLONE_NEWNET, CLONE_NEWNS, // CLONE_NEWPID, CLONE_NEWUSER, CLONE_NEWUTS\nint clone(int (*fn)(void *), void *child_stack, int flags, void *arg)\nsetns\n该系统调用可以让调用进程加入某个已经存在的 namespace 中：\nint setns(int fd, int nstype)\nunshare\n该系统调用可以将调用进程移动到新的 namespace 下：\nint unshare(int flags)\n关于 namespace 的常用操作 查看当前系统的 namespace：lsns -t \u0026lt;type\u0026gt; 查看某进程的 namespace：ls -la /proc/\u0026lt;pid\u0026gt;/ns/ 进入某 namespace 运行命令：nsenter -t \u0026lt;pid\u0026gt; -n ip addr namespace 练习 在新的 network namespace 执行 sleep 指令\nunshar -fn sleep 120\n查看进程信息\nps -ef | grep sleep\nroot 476484 476437 0 00:37 pts/3 00:00:00 unshare -fn sleep 120\nroot 476485 476484 0 00:37 pts/3 00:00:00 sleep 120\n查看网络 namespace\nlsns -t net\n4026532266 net 2 476484 root unassigned unshare -fn sleep 120\n进入该进程所在 namespace 查看网络配置，与主机不一样\nnsenter -t pid -n ip a\n1: lo: mtu 65536 qdisc noop state DOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\ncgroups（可配额） Cgroups (control groups) 是 linux 下用于对一个或一组进程进行资源控制和监控的机制。\n可以对诸如 CPU 使用时间、内存、磁盘I/O 等进程所需资源进行限制。\n不同资源的具体管理工作由相应的 cgroup 子系统来实现。\n针对不同类型的资源限制，只要将限制策略在不同的子系统上进行关联即可。\ncgroups 在不同的系统资源管理子系统中已层级树（Hierarchy）的方式来组织管理： 每个 cgroup 都可包含其他的子 cgroup，因此子 cgroup 能够使用的资源除了 受本 cgroup 配置的资源参数的限制，还受到父 cgroup 设置的资源限制。\nlinux 内核代码中 cgroups 的实现 进程数据结构 struct task_struct { ... #ifdef CONFIG_CGROUPS struct css_set __rcu *cgroups; struct list_head cg_list; #endif ... } 这里 nsproxy 属性就表示这个进程所在的 namespace 的信息。\ncss_set 是 cgroup_subsys_state 对象的集合 struct css_set { /* * Set of subsystem states, one for each subsystem. This array is * immutable after creation apart from the init_css_set during * subsystem registration (at boot time). */ struct cgroup_subsys_state *subsys[CGROUP_SUBSYS_COUNT]; } CPU 子系统 cpu.shares：可让出的能获得 CPU 使用时间的相对值。 cpu.cfs_period_us：用来配置时间周期长度，单位为 us（微秒）。 cpu.cfs_quota_us：用来配置当前 cgroup 在 cfs_period_us 时间内最多能使用的 CPU 时间数，单位为 us（微秒）。 cpu.stat：cgroup 内的进程使用的 CPU 时间统计。 nr_periods：经过 cfs_period_us 的时间周期数量。 nr_throttled：在经过的周期内，由多少次因为进程在指定的时间周期内用光了配额时间而受到限制。 throttled_time：cgroup 中的进程被限制使用 CPU 的总用时，单位为 ns（纳秒）。 CPU 子系统练习 在 cgroup cpu 子系统目录中创建目录结构\ncd /sys/fs/cgroup/cpu mkdir cpudemo cd cpudemo 运行 busyloop（代码如下）\npackage main func main() { go func() { for {} }() for {} } 执行 top 查看 CPU 使用情况，CPU 占 100%（我的ecs只有一核）\n通过 cgroup 限制 CPU 使用\n把进程添加到 cgroup 进程配置组 echo ps -ef | grep busyloop | grep -v grep | awk '{print $2}' \u0026gt; cgroup.procs 设置 cpuquota echo 10000 \u0026gt; cpu.cfs_quota_us // 每 10 万个 CPU 时间片只能拿到 1 万个 执行 top 查看 CPU 使用情况，CPU 占用变为 10%\nmemory 子系统 memory.usage_in_bytes：cgroup 下进程使用的内存，包含 cgroup 及其子 cgroup 下的进程使用的内存。 memory.max_usage_in_bytes：cgroup 下进程使用内存的最大值，包含子 cgroup 的内存使用量。 memory.limit_in_bytes：设置 cgroup 下进程最多能使用的内存。如果设置为 -1，表示对该 cgroup 的内存使用不作限制。 memory.oom_control：设置是否在 cgroup 中使用 OOM (Out Of Memory) Killer，默认为使用。 当属于该 cgroup 的进程使用的内存超过最大的限定值时，会立刻被 OOM Killer 处理。 Union FS // TODO\n","permalink":"https://theone-daxia.github.io/blog/code/docker/base/","summary":"namespace（隔离性） linux namespace 是一种 linux kernel 提供的资源隔离方案：\n系统可以为进程分配不同的 namespace。 保证不同的 namespace 资源独立分配、进程彼此隔离，即不同 namespace 下的进程互不干扰。 linux 内核代码中 namespace 的实现 进程数据结构 struct task_struct { ... /* namespaces */ struct nsproxy *nsproxy; ... } 这里 nsproxy 属性就表示这个进程所在的 namespace 的信息。\nnamespace 数据结构 struct nsproxy { atomic_t count; struct uts_namespace *uts_ns; struct ipc_namespace *ipc_ns; struct mnt_namespace *mnt_ns; struct pid_namespace *pid_ns_for_children; struct net *net_ns; } linux 对 namespace 的操作方法 clone\n在创建新进程的系统调用时，可以通过 flags 参数指定需要新建的 namespace 类型： // CLONE_NEWCGROUP, CLONE_NEWIPC, CLONE_NEWNET, CLONE_NEWNS, // CLONE_NEWPID, CLONE_NEWUSER, CLONE_NEWUTS","title":"docker核心技术"},{"content":"什么是 RST TCP 正常情况下断开连接是用四次挥手，但异常情况下，收发双方都不一定正常， 可能做不到挥手，所以就需要一个机制去强行关闭连接。\nRST 就是用于这种情况，一般用来异常的关闭一个连接。它是 TCP 包头的一个标志位。 正常情况下，不管是发出还是收到 RST 数据包，相应的内存、端口等连接资源就会被释放， 效果上看，就是 TCP 连接被关闭了。收到 RST 的一方，一般会看到 connection reset 或 connection refused 的报错。\n如何知道收到了 RST 内核跟应用层是分开的两层，网络通信功能在内核，客户端或服务端属于应用层。 应用层只能通过 send/recv 与内核交互，才能感知到内核是否收到了 RST。\n当本端收到远端发来的 RST 后，内核认为此连接已经关闭。\n此时如果本端应用层尝试执行读操作（recv），应用层就会收到 Connection reset by peer 的报错，意思是远端已经关闭连接。\n如果本端应用层尝试执行写操作（send），应用层就会收到 Broken pipe 的报错，意思是发送通道已经坏了。\n出现 RST 的场景有哪些 一般归类为 对端的端口不可用 和 socket 提前关闭\n端口未监听\n连接一个未监听的端口，服务端收到客户端的 SYN 后，会根据 IP 和 端口从全局哈希表获取 sock， 服务端没执行过 listen()，不会有对应的 sock，正常情况下，服务端会发送一个 RST。\n不正常情况：比如 tcp_checksum_complete() 检验后发现数据包校验和不合法，就会直接丢弃，不发 RST。\n程序启动过，但现在崩了\n本质上跟端口未监听一样。服务端程序崩溃后，原来监听的端口资源就会被释放， 此时服务端收到了来自客户端的消息，查找不到 sock，回一个 RST。\n如果在客户端和服务端之间加个 nginx，服务端程序崩溃，nginx 收到 RST，就会回复客户端一个 502。\n本端提前关闭 socket\n如果本端 socket 接收缓冲区还有数据未读，此时提前 close() socket， 那么本端会先把接收缓冲区的数据清空，然后给远端发一个 RST。\n远端提前关闭 socket\n远端已经 close() 了 socket，此时本端还尝试发数据给远端，远端就会回一个 RST。\n对方没收到 RST 会怎样 RST 不需要 ACK 应答。\n如果对方没收到 RST：\n如果客户端之前发送了数据，一直没等到 ACK，就会重发，重发的时候就会收到一个新的 RST。 如果客户端之前没发数据，TCP 有个 keepalive 机制，会定期发送探活包，这个包到了服务端，会重新触发一个 RST。 收到 RST 就一定会断开连接么 不一定。\n// net/ipv4/tcp_input.c static bool tcp_validate_incoming() { // 获取sock struct tcp_sock *tp = tcp_sk(sk); // step 1：先判断seq是否合法（是否在合法接收窗口范围内） if (!tcp_sequence(tp, TCP_SKB_CB(skb)-\u0026gt;seq, TCP_SKB_CB(skb)-\u0026gt;end_seq)) { goto discard; } // step 2：执行收到 RST 后该干的事情 if (th-\u0026gt;rst) { if (TCP_SKB_CB(skb)-\u0026gt;seq == tp-\u0026gt;rcv_nxt) tcp_reset(sk); else tcp_send_challenge_ack(sk); goto discard; } } 收到 RST 后，先通过 tcp_sequence() 判断 seq 是否在合法的接收窗口范围内， 如果不在，这个 RST 包就会被直接丢弃。这个判断会加大 RST 攻击的难度。\nRST 攻击，构造出合法 seq 的方式：\n盲猜 seq（seq 本质是一个 uint32 类型的数据） 利用 challenge ack，然后在一定范围内设置 seq 参考文献 收到 RST 就一定会断开连接么 ","permalink":"https://theone-daxia.github.io/blog/code/linux/rst/","summary":"什么是 RST TCP 正常情况下断开连接是用四次挥手，但异常情况下，收发双方都不一定正常， 可能做不到挥手，所以就需要一个机制去强行关闭连接。\nRST 就是用于这种情况，一般用来异常的关闭一个连接。它是 TCP 包头的一个标志位。 正常情况下，不管是发出还是收到 RST 数据包，相应的内存、端口等连接资源就会被释放， 效果上看，就是 TCP 连接被关闭了。收到 RST 的一方，一般会看到 connection reset 或 connection refused 的报错。\n如何知道收到了 RST 内核跟应用层是分开的两层，网络通信功能在内核，客户端或服务端属于应用层。 应用层只能通过 send/recv 与内核交互，才能感知到内核是否收到了 RST。\n当本端收到远端发来的 RST 后，内核认为此连接已经关闭。\n此时如果本端应用层尝试执行读操作（recv），应用层就会收到 Connection reset by peer 的报错，意思是远端已经关闭连接。\n如果本端应用层尝试执行写操作（send），应用层就会收到 Broken pipe 的报错，意思是发送通道已经坏了。\n出现 RST 的场景有哪些 一般归类为 对端的端口不可用 和 socket 提前关闭\n端口未监听\n连接一个未监听的端口，服务端收到客户端的 SYN 后，会根据 IP 和 端口从全局哈希表获取 sock， 服务端没执行过 listen()，不会有对应的 sock，正常情况下，服务端会发送一个 RST。\n不正常情况：比如 tcp_checksum_complete() 检验后发现数据包校验和不合法，就会直接丢弃，不发 RST。\n程序启动过，但现在崩了\n本质上跟端口未监听一样。服务端程序崩溃后，原来监听的端口资源就会被释放， 此时服务端收到了来自客户端的消息，查找不到 sock，回一个 RST。","title":"TCP 之 RST"},{"content":"简介 这是一个用 go 编写的聊天小项目，使用到了\ngo gin websocket redis // 存储过期消息、记录信息发送次数等 mysql // 存储用户信息 mongo // 存储聊天信息 目前支持的功能有：\n用户注册 双人单聊 拉取历史记录 简要逻辑说明：\nread()： 接收 client 发来的消息，放到广播里。 write()： 将广播里的消息，发送给对应的 client。 manager：管理 client。 我的项目代码：https://github.com/theone-daxia/chat-demo\n运行准备 下载安装 docker desktop 分别拉取 redis、mysql、mongo 镜像并运行 可用 postman 来进行请求（支持 ws 请求） 知识盘点 websocket\nwebsocket 是一个持久化的、基于 tcp 的协议，实现了浏览器和服务器的全双工通信， 节省服务器资源并达到实时通讯的目的。\n通信过程如下：\n首先，客户端发起 http 请求，3次握手后，建立起 tcp 连接， http 请求里存放 websocket 相关信息，如：Upgrade、Connection、WebSocket-Version 等。 然后，服务器收到客户端的握手请求后，同样采用 http 协议回馈数据。 最后，客户端收到连接成功消息后，开始通过 tcp 传输信道进行全双工通信。 与 http 的不同点可参考：WebSocket 介绍\nmongo 相关命令\n容器内打开mongo mongosh // 注意：5.0版本以下才用 mongo 命令打开，\nThe mongo shell has been deprecated in MongoDB v5.0. The replacement is mongosh.\nCURD\ndb.collection.insertOne() // 将单个文档插入集合中 db.collection.find() // 查询集合中所有文档 db.getCollection(\u0026#34;1-\u0026gt;2\u0026#34;).find() // 名字包含特殊字符的集合的查询 db.collection.deleteMany({}) // 删除集合中所有文档 ... 加载 .ini 文件\nimport \u0026#34;gopkg.in/ini.v1\u0026#34; file, err := ini.Load(\u0026#34;./config/config.ini\u0026#34;) redis、mysql、mongo 连接\n// redis 连接 import \u0026#34;github.com/go-redis/redis\u0026#34; client := redis.NewClient(\u0026amp;redis.Options{ Addr: RedisAddr, DB: int(db), }) _, err := client.Ping().Result() // mysql 连接 import ( \u0026#34;gorm.io/driver/mysql\u0026#34; \u0026#34;gorm.io/gorm\u0026#34; ) dsn := DBUser + \u0026#34;:\u0026#34; + DBPassword + \u0026#34;@tcp(\u0026#34; + DBHost + \u0026#34;:\u0026#34; + DBPort + \u0026#34;)/\u0026#34; + DBName + \u0026#34;?charset=utf8mb4\u0026amp;parseTime=true\u0026amp;loc=Local\u0026#34; DB, err := gorm.Open(mysql.Open(dsn), \u0026amp;gorm.Config{}) // mongo 连接 import ( \u0026#34;context\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/mongo\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/mongo/options\u0026#34; ) clientOptions := options.Client().ApplyURI(\u0026#34;mongodb://\u0026#34; + MongoDBAddr + \u0026#34;:\u0026#34; + MongoDBPort) MongoDBClient, err := mongo.Connect(context.TODO(), clientOptions) 参考项目 github.com/CocaineCong/gin-chat-demo github.com/gorilla/websocket@v1.5.0/examples/chat ","permalink":"https://theone-daxia.github.io/blog/code/go/chat-demo/","summary":"简介 这是一个用 go 编写的聊天小项目，使用到了\ngo gin websocket redis // 存储过期消息、记录信息发送次数等 mysql // 存储用户信息 mongo // 存储聊天信息 目前支持的功能有：\n用户注册 双人单聊 拉取历史记录 简要逻辑说明：\nread()： 接收 client 发来的消息，放到广播里。 write()： 将广播里的消息，发送给对应的 client。 manager：管理 client。 我的项目代码：https://github.com/theone-daxia/chat-demo\n运行准备 下载安装 docker desktop 分别拉取 redis、mysql、mongo 镜像并运行 可用 postman 来进行请求（支持 ws 请求） 知识盘点 websocket\nwebsocket 是一个持久化的、基于 tcp 的协议，实现了浏览器和服务器的全双工通信， 节省服务器资源并达到实时通讯的目的。\n通信过程如下：\n首先，客户端发起 http 请求，3次握手后，建立起 tcp 连接， http 请求里存放 websocket 相关信息，如：Upgrade、Connection、WebSocket-Version 等。 然后，服务器收到客户端的握手请求后，同样采用 http 协议回馈数据。 最后，客户端收到连接成功消息后，开始通过 tcp 传输信道进行全双工通信。 与 http 的不同点可参考：WebSocket 介绍","title":"练手小项目-Chat Demo"},{"content":"简介 这是一个用 go 编写的终端小游戏，设计很简单：\n玩家在一个迷宫中行走，上下左右控制方向； 吃蛋糕加一分，遇到怪物死亡（减一条命）且短暂延时后玩家在原始位置重生； 吃到加强弹药加十分且怪物在一段时间内变得愤怒， 没命或者按 Esc 键则退出游戏。 运行展示如下 我的项目代码：https://github.com/theone-daxia/pacman\n知识盘点 打开文件\nimport \u0026#34;os\u0026#34; file := \u0026#34;maze01.txt\u0026#34; os.Open(file) 读取文件内容\nimport \u0026#34;bufio\u0026#34; scanner := bufio.NewScanner(f) for scanner.Scan() { line := scanner.Text() maze = append(maze, line) } 调用外部命令\nimport \u0026#34;os/exec\u0026#34; cbTerm := exec.Command(\u0026#34;stty\u0026#34;, \u0026#34;cbreak\u0026#34;, \u0026#34;-echo\u0026#34;) cbTerm.Stdin = os.Stdin err := cbTerm.Run() 终端模式\nCooked Mode Cbreak Mode Raw Mode cooked mode 是 Unix-style tty(比如 console) 处理输入的默认模式， 用户可以输入一行字符，在按回车前程序是看不到的。 在 cooked mode 下，数据在被提供给程序之前被预处理，而 raw mode 将数据按原样传递给程序而不解释任何特殊字符。\ncbreak mode 是介于 raw 和 cooked mode 之间的一种模式。与 cooked mode 不同，它一次只处理单个字符， 而不是强制等待整行然后一次性输入所有行。 与 raw mode 不同，像中止这样的击键（通常是 Control-C）仍然由终端处理并且会中断进程。\n使用 stty 命令设置终端行（带 - 关闭相应功能，不带 - 则打开相应功能） 关闭输入立即响应模式，打开回显 stty -cbreak echo 关闭回显，打开输入立即响应模式 stty cbreak -echo 从标准输入读取字符\nimport \u0026#34;os\u0026#34; func readInput() (string, error) { buffer := make([]byte, 100) cnt, err := os.Stdin.Read(buffer) if err != nil { return \u0026#34;\u0026#34;, err } if cnt == 1 \u0026amp;\u0026amp; buffer[0] == 0x1b { // 0x1b 是 esc 的16进制表示 return \u0026#34;ESC\u0026#34;, nil } else if cnt \u0026gt;= 3 { if buffer[0] == 0x1b \u0026amp;\u0026amp; buffer[1] == \u0026#39;[\u0026#39; { switch buffer[2] { case \u0026#39;A\u0026#39;: return \u0026#34;UP\u0026#34;, nil case \u0026#39;B\u0026#39;: return \u0026#34;DOWN\u0026#34;, nil case \u0026#39;C\u0026#39;: return \u0026#34;RIGHT\u0026#34;, nil case \u0026#39;D\u0026#39;: return \u0026#34;LEFT\u0026#34;, nil } } } return \u0026#34;\u0026#34;, nil } 处理转义序列\n转义序列以 Esc（0x1b）开头，后面跟一个或多个字符，一个转义序列对终端来说就是一个命令。\n使用 simpleansi 包处理转义序列\nimport \u0026#34;github.com/danicat/simpleansi\u0026#34; simpleansi.ClearScreen() // 清理屏幕 simpleansi.MoveCursor(row int, col int) // 移动光标 使用协程处理怪物移动、怪物变愤怒\n使用 channel 监听用户输入\n使用 Timer 处理怪物变愤怒的时间\n加载 .json 文件并存储在变量中\nimport ( \u0026#34;os\u0026#34; \u0026#34;encoding/json\u0026#34; ) func loadTheme(file string) error { f, err := os.Open(file) if err != nil { return err } defer f.Close() decoder := json.NewDecoder(f) err = decoder.Decode(\u0026amp;theme) if err != nil { return err } return nil } 给命令行应用添加 flags\n// 添加两个 flag --theme-file --maze-file // 可以 --help 查看新添加的 flag 信息 // 使用示例：go rum main --theme-file theme/emoji.json import \u0026#34;flag\u0026#34; var ( themeFile = flag.String(\u0026#34;theme-file\u0026#34;, \u0026#34;theme/emoji.json\u0026#34;, \u0026#34;path to custom theme file\u0026#34;) mazeFile = flag.String(\u0026#34;maze-file\u0026#34;, \u0026#34;maze01.txt\u0026#34;, \u0026#34;path to custom maze file\u0026#34;) ) 使用 buffer 进行字符串连接\n使用 buffer 连接，只在初始化时分配内存，相比 + 方式更高效； 用 + 连接时，循环每次迭代都会进行内存分配。\nimport \u0026#34;bytes\u0026#34; func getLivesAsEmoji() string{ buf := bytes.Buffer{} for i := lives; i \u0026gt; 0; i-- { buf.WriteString(cfg.Player) } return buf.String() } 使用锁来处理 data race\nsync.Mutex 处理吃到加强弹药后怪物的更改 sync.RWMutex 处理怪物状态的读取和写入 参考项目 pacgo ","permalink":"https://theone-daxia.github.io/blog/code/go/pacman/","summary":"简介 这是一个用 go 编写的终端小游戏，设计很简单：\n玩家在一个迷宫中行走，上下左右控制方向； 吃蛋糕加一分，遇到怪物死亡（减一条命）且短暂延时后玩家在原始位置重生； 吃到加强弹药加十分且怪物在一段时间内变得愤怒， 没命或者按 Esc 键则退出游戏。 运行展示如下 我的项目代码：https://github.com/theone-daxia/pacman\n知识盘点 打开文件\nimport \u0026#34;os\u0026#34; file := \u0026#34;maze01.txt\u0026#34; os.Open(file) 读取文件内容\nimport \u0026#34;bufio\u0026#34; scanner := bufio.NewScanner(f) for scanner.Scan() { line := scanner.Text() maze = append(maze, line) } 调用外部命令\nimport \u0026#34;os/exec\u0026#34; cbTerm := exec.Command(\u0026#34;stty\u0026#34;, \u0026#34;cbreak\u0026#34;, \u0026#34;-echo\u0026#34;) cbTerm.Stdin = os.Stdin err := cbTerm.Run() 终端模式\nCooked Mode Cbreak Mode Raw Mode cooked mode 是 Unix-style tty(比如 console) 处理输入的默认模式， 用户可以输入一行字符，在按回车前程序是看不到的。 在 cooked mode 下，数据在被提供给程序之前被预处理，而 raw mode 将数据按原样传递给程序而不解释任何特殊字符。","title":"练手小项目-Pacman"},{"content":"问题 如题，安装 maatwebsite/excel 3.x 版本失败，提示各种依赖不满足\n解决 在提示的最后一行有下面这句\nUse the option --with-all-dependencies (-W) to allow upgrades, downgrades and removals for packages currently locked to specific versions. 所以执行 composer require maatwebsite/excel ^3.1 -W 即可。\n","permalink":"https://theone-daxia.github.io/blog/code/laravel/composer/","summary":"问题 如题，安装 maatwebsite/excel 3.x 版本失败，提示各种依赖不满足\n解决 在提示的最后一行有下面这句\nUse the option --with-all-dependencies (-W) to allow upgrades, downgrades and removals for packages currently locked to specific versions. 所以执行 composer require maatwebsite/excel ^3.1 -W 即可。","title":"composer require maatwebsite/excel ^3.1 失败"},{"content":"laravel 设置 https 的几种情况 提交表单，提示不安全问题 \u0026lt;!-- 原来的写法 --\u0026gt; \u0026lt;form action=\u0026#34;{{ route(\u0026#39;order/import\u0026#39;) }}\u0026#34; method=\u0026#34;POST\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt;\u0026lt;/form\u0026gt; \u0026lt;!-- 修改后的写法 --\u0026gt; \u0026lt;!-- --\u0026gt; \u0026lt;form action=\u0026#34;{{ secure_url(\u0026#39;order/import\u0026#39;) }}\u0026#34; method=\u0026#34;POST\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt;\u0026lt;/form\u0026gt; 即使用 secure_url() 方法替换 route() 方法即可。\n注意：使用 secure_url() 时，如果不是相对路径，则需要将第三个参数设置为 false， 即 secure_url(\u0026lsquo;your path\u0026rsquo;, [], false)。\n全局使用 https 在使用相关框架做管理后台开发，比如 nova、laravel-admin、orchid 等， 需要配置使用 https 时，有以下两种方法。\n1. 修改 nginx 配置 在对应项目的 nginx 配置中，添加 fastcgi_patam HTTPS on;\nlocation ~ [^/]\\.php(/|$) { #fastcgi_pass remote_php_ip:9000; fastcgi_pass unix:/dev/shm/php-cgi.sock; fastcgi_index index.php; fastcgi_param HTTPS on; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } 2. 修改项目代码 在项目代码 app/Providers/AppServiceProvider.php 文件的 boot() 方法中，添加如下代码\n\\Illuminate\\Support\\Facades\\URL::forceScheme(\u0026#39;https\u0026#39;); 但是这种修改方式还是可能出现生成链接错误的情况， 比如 route(config(platform.index))， 所以如果你的项目全局都用 https，直接修改对应 nginx 配置最好。\n总结 其实 laravel 不关心 url 是否安全，它是基于当前 url 生成的。 如果在 https 页面上，route() 将返回安全的网址， 如果在 http 页面上，将返回 http:// 网址。\n由于使用了 nginx，监听 443 端口，将请求转发到 8081端口，laravel 接收到的 request 都会是 http。\n所以如果需要全局使用 https，最好是修改对应项目的 nginx 配置。\n","permalink":"https://theone-daxia.github.io/blog/code/laravel/https/","summary":"laravel 设置 https 的几种情况 提交表单，提示不安全问题 \u0026lt;!-- 原来的写法 --\u0026gt; \u0026lt;form action=\u0026#34;{{ route(\u0026#39;order/import\u0026#39;) }}\u0026#34; method=\u0026#34;POST\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt;\u0026lt;/form\u0026gt; \u0026lt;!-- 修改后的写法 --\u0026gt; \u0026lt;!-- --\u0026gt; \u0026lt;form action=\u0026#34;{{ secure_url(\u0026#39;order/import\u0026#39;) }}\u0026#34; method=\u0026#34;POST\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt;\u0026lt;/form\u0026gt; 即使用 secure_url() 方法替换 route() 方法即可。\n注意：使用 secure_url() 时，如果不是相对路径，则需要将第三个参数设置为 false， 即 secure_url(\u0026lsquo;your path\u0026rsquo;, [], false)。\n全局使用 https 在使用相关框架做管理后台开发，比如 nova、laravel-admin、orchid 等， 需要配置使用 https 时，有以下两种方法。\n1. 修改 nginx 配置 在对应项目的 nginx 配置中，添加 fastcgi_patam HTTPS on;\nlocation ~ [^/]\\.php(/|$) { #fastcgi_pass remote_php_ip:9000; fastcgi_pass unix:/dev/shm/php-cgi.sock; fastcgi_index index.php; fastcgi_param HTTPS on; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } 2.","title":"laravel 配置 https"},{"content":"问题列表 mac 系统升级后，使用 homebrew 报错，提示 \u0026ldquo;brew-core is a shallow clone\u0026rdquo;\n➜ ~ brew install docker Error: homebrew-core is a shallow clone. To `brew update`, first run: git -C /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core fetch --unshallow This command may take a few minutes to run due to the large size of the repository. This restriction has been made on GitHub\u0026#39;s request because updating shallow clones is an extremely expensive operation due to the tree layout and traffic of Homebrew/homebrew-core and Homebrew/homebrew-cask. We don\u0026#39;t do this for you automatically to avoid repeatedly performing an expensive unshallow operation in CI systems (which should instead be fixed to not use shallow clones). Sorry for the inconvenience! 按照提示执行命令，因为源的问题总是执行不了，更换中科大的源也不行，最终解决办法如下\ncd /usr/local/Homebrew/Library/Taps/homebrew rm -rf homebrew-core brew upgrade ","permalink":"https://theone-daxia.github.io/blog/code/mac/homebrew/","summary":"问题列表 mac 系统升级后，使用 homebrew 报错，提示 \u0026ldquo;brew-core is a shallow clone\u0026rdquo;\n➜ ~ brew install docker Error: homebrew-core is a shallow clone. To `brew update`, first run: git -C /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core fetch --unshallow This command may take a few minutes to run due to the large size of the repository. This restriction has been made on GitHub\u0026#39;s request because updating shallow clones is an extremely expensive operation due to the tree layout and traffic of Homebrew/homebrew-core and Homebrew/homebrew-cask.","title":"Homebrew 相关问题"},{"content":"起因 最近换了个电脑，克隆自己的私有仓库时失败， 总是报权限相关的问题。查询文档后，找到解决办法。\n文档链接：https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token\n解决办法 根据文档，按照如下步骤操作：\n点击个人头像，在下拉菜单中点击 Settings 点击左边菜单栏最下面的 Developer settings 点击 Personal access tokens 点击 Fine-grained tokens 点击 Generate new token 然后就是按照页面上的选项操作，比如给 token 起名、选择仓库、选择权限、选择过期时间等 最后生成 token，点击复制 再次操作克隆 git clone https://xxx，回车后会让你输入用户名和密码，密码就输入刚才复制的 token，结束！ ","permalink":"https://theone-daxia.github.io/blog/code/github/clone-private/","summary":"起因 最近换了个电脑，克隆自己的私有仓库时失败， 总是报权限相关的问题。查询文档后，找到解决办法。\n文档链接：https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token\n解决办法 根据文档，按照如下步骤操作：\n点击个人头像，在下拉菜单中点击 Settings 点击左边菜单栏最下面的 Developer settings 点击 Personal access tokens 点击 Fine-grained tokens 点击 Generate new token 然后就是按照页面上的选项操作，比如给 token 起名、选择仓库、选择权限、选择过期时间等 最后生成 token，点击复制 再次操作克隆 git clone https://xxx，回车后会让你输入用户名和密码，密码就输入刚才复制的 token，结束！ ","title":"github 克隆自己的私有仓库"},{"content":"前言 网上有很多讲 go gc 的文章，但大多讲的不明不白， 一些突然出现的术语更是不知从何而起，导致看过一些文章后对 gc 依旧云里雾里。 好在最近在公众号看到了一篇文章，我觉得写的很赞， 起码解答了那些突然出现的术语是什么。\n我决定把它搬运到这里，手写一遍记忆更加深刻。 接下来是对原文的默写，忘了就直接抄写。\n原文中会贴出一些 go 的源代码，我本地 go 版本是 1.18.2，对照看的时候会有些出入， 出入的地方我就改贴上我本地的 go 源代码。 所有图片都来源于原文，原文地址在最下面参考文献中列出。 默写加抄写 本文以 go 内存管理为切入点，再到 go 垃圾回收，系统的讲解了 go 自动内存管理系统的设计和原理。\n一、TCMalloc go 的内存管理借鉴了 TCMalloc 的设计思想，TCMalloc 全称 Thread-Caching Malloc， 是 google 开发的内存分配器，为了方便理解 go 的内存管理，有必要先熟悉下 TCMalloc。\n(一) Page 操作系统对内存的管理以页为单位，TCMalloc 也是这样， 只不过 TCMalloc 里的 Page 大小与操作系统里的大小不一定相等，是倍数的关系。\n(二) Span 一组连续的 Page 称为 Span，比如可以有 4 个页大小的 Span，也可以有 8 个页大小的 Span。 Span 比 Page 高一个层级，是为了方便管理一定大小的内存区域， Span 是 TCMalloc 中内存管理的基本单位。\n(三) ThreadCache 每个线程各自的 Cache，一个 Cache 包含多个空闲的内存块链表， 同一个链表上的内存块大小相同，也可以说按内存块大小，给内存块分了个类， 这样可以根据申请的内存大小，快速从合适的链表上选择空闲内存块。 由于每个线程都有自己的 ThreadCache，所以 ThreadCache 的访问是无锁的。\n(四) CentralCache 是所有线程共享的缓存，也是保存的空闲内存块链表， 链表的数量和 ThreadCache 中链表的数量相同。 当 ThreadCache 内存块不足时，可以从 CentralCache 取， 当 ThreadCache 内存块多时，可以放回 CentralCache。 由于 CentralCache 是共享的，所以它的访问是要加锁的。\n(五) PageHeap PageHeap 是堆内存的抽象，存的也是若干链表，链表保存的是 Span， 当 CentralCache 没有内存时，会从 PageHeap 取， 把一个 Span 拆成若干内存块，添加到对应大小的链表中， 当 CentralCache 内存多时，会放回 PageHeap。\n(六) TCMalloc 对象分配 小对象直接从 ThreadCache 分配， 若 ThreadCache 不够，则从 CentralCache 中获取内存， 若 CentralCache 不够，则从 PageHeap 中获取内存； 大对象在 PageHeap 中选取合适的页组成 Span 用于存储数据。\n二、go 内存管理 go 内存管理架构取之 TCMalloc，不过在细节上有些出入， 先来看一张 go 内存管理架构图：\n(一) Page 和 TCMalloc 中的 Page 相同，上图中最下方浅蓝色长方形代表一个 Page。\n(二) Span 与 TCMalloc 中的 Span 相同，Span 是 go 内存管理的基本单位，代码中为 mspan， 一组连续的 Page 组成一个 Span。\n(三) mcache mcache 与 TCMalloc 中的 ThreadCache 类似，mcache 保存的是各种大小的 Span， 并按 Span class 分类，小对象直接从 mcache 分配内存，它起到了缓存的作用， 并且可以无锁访问。\n但 mcache 和 ThreadCache 也有不同点，TCMalloc 中是每个线程一个 ThreadCache， go 中是每个 P 拥有一个 mcache，因为在 go 程序中，当前最多有 GOMAXPROCS 个线程在运行， 所以最多需要 GOMAXPROCS 个 mcache 就可以保证各线程对 mcache 的无锁访问。 下图是 G、P、M 三者之间的关系：\n(四) mcentral mcentral 与 TCMalloc 中的 CentralCache 类似，是所有线程共享的缓存，需要加锁访问。 它按 Span class 对 Span 分类，串联成链表，当 mcache 的某个级别 Span 的内存被分配光时， 它会向 mcentral 申请一个当前级别的 Span。\n但 mcentral 与 CentralCache 也有不同点， CentralCache 是每个级别的 Span 有一个链表， mcentral 是每个级别的 Span 有两个链表。\n(五) mheap mheap 与 TCMalloc 的 PageHeap 类似，它是堆内存的抽象，把从 OS 申请出的内存页组织成 Span， 并保存起来。当 mcentral 的 Span 不够用时会向 mheap 申请， mheap 的 Span 不够用时会向 OS 申请，把从 OS 申请的内存页生成 Span 组织起来，需要加锁访问。\n但 mheap 与 PageHeap 也有不同点， mheap 把 Span 组织成了树结构，而不是链表，并且还是两棵树， 然后把 Span 分配到 heapArena 进行管理，它包含地址映射和 Span 是否包含指针等位图， 这样做的主要原因是为了更高效的利用内存：分配、回收和再利用。\n(六) 内存分配 TCMalloc 的内存分类分为：小、中、大对象， go 分为：Tiny、小、大对象。 Tiny 对象指大小在 1Byte 到 16Byte 之间且不包含指针的对象。 小对象和大对象只用大小划定，无其他区分， 小对象大小在 16Byte 到 32KB 之间， 大对象大小大于 32KB。\ngo 的内存管理基本单位是 Span，且 Span 有不同的规格，想要区分出不同的 Span， 就得有个标识，每个 Span 通过 spanclass 标识属于哪种规格的 Span， go 的 Span 一共有 67 种，具体如下：\n// from runtime/sizeclasses.go // class bytes/obj bytes/span objects tail waste max waste min align // 1 8 8192 1024 0 87.50% 8 // 2 16 8192 512 0 43.75% 16 // 3 24 8192 341 8 29.24% 8 // 4 32 8192 256 0 21.88% 32 // 5 48 8192 170 32 31.52% 16 // 6 64 8192 128 0 23.44% 64 // 7 80 8192 102 32 19.07% 16 // 8 96 8192 85 32 15.95% 32 // 9 112 8192 73 16 13.56% 16 // 10 128 8192 64 0 11.72% 128 // 11 144 8192 56 128 11.82% 16 // 12 160 8192 51 32 9.73% 32 // 13 176 8192 46 96 9.59% 16 // 14 192 8192 42 128 9.25% 64 // 15 208 8192 39 80 8.12% 16 // 16 224 8192 36 128 8.15% 32 // 17 240 8192 34 32 6.62% 16 // 18 256 8192 32 0 5.86% 256 // 19 288 8192 28 128 12.16% 32 // 20 320 8192 25 192 11.80% 64 // 21 352 8192 23 96 9.88% 32 // 22 384 8192 21 128 9.51% 128 // 23 416 8192 19 288 10.71% 32 // 24 448 8192 18 128 8.37% 64 // 25 480 8192 17 32 6.82% 32 // 26 512 8192 16 0 6.05% 512 // 27 576 8192 14 128 12.33% 64 // 28 640 8192 12 512 15.48% 128 // 29 704 8192 11 448 13.93% 64 // 30 768 8192 10 512 13.94% 256 // 31 896 8192 9 128 15.52% 128 // 32 1024 8192 8 0 12.40% 1024 // 33 1152 8192 7 128 12.41% 128 // 34 1280 8192 6 512 15.55% 256 // 35 1408 16384 11 896 14.00% 128 // 36 1536 8192 5 512 14.00% 512 // 37 1792 16384 9 256 15.57% 256 // 38 2048 8192 4 0 12.45% 2048 // 39 2304 16384 7 256 12.46% 256 // 40 2688 8192 3 128 15.59% 128 // 41 3072 24576 8 0 12.47% 1024 // 42 3200 16384 5 384 6.22% 128 // 43 3456 24576 7 384 8.83% 128 // 44 4096 8192 2 0 15.60% 4096 // 45 4864 24576 5 256 16.65% 256 // 46 5376 16384 3 256 10.92% 256 // 47 6144 24576 4 0 12.48% 2048 // 48 6528 32768 5 128 6.23% 128 // 49 6784 40960 6 256 4.36% 128 // 50 6912 49152 7 768 3.37% 256 // 51 8192 8192 1 0 15.61% 8192 // 52 9472 57344 6 512 14.28% 256 // 53 9728 49152 5 512 3.64% 512 // 54 10240 40960 4 0 4.99% 2048 // 55 10880 32768 3 128 6.24% 128 // 56 12288 24576 2 0 11.45% 4096 // 57 13568 40960 3 256 9.99% 256 // 58 14336 57344 4 0 5.35% 2048 // 59 16384 16384 1 0 12.49% 8192 // 60 18432 73728 4 0 11.11% 2048 // 61 19072 57344 3 128 3.57% 128 // 62 20480 40960 2 0 6.87% 4096 // 63 21760 65536 3 256 6.25% 256 // 64 24576 24576 1 0 11.45% 8192 // 65 27264 81920 3 128 10.00% 128 // 66 28672 57344 2 0 4.91% 4096 // 67 32768 32768 1 0 12.50% 8192 由上表可见，最大的对象大小为 32KB，超过 32KB 大小的由特殊 class 表示， 该 class ID 为 0，每个 class 只包含一个对象。\n内存大小转换，有 3 个数组，对应下图中的三个箭头：\nclass_to_size size_to_class class_to_allocnpages class 1 的对象大小为 8Byte，所以 class_to_size[1] = 8； span 大小是 8KB，为 1 页（因为 go 内存管理以 8KB 为一页）， 所以 class_to_allocnpages[1] = 1，下面是源码中大小转换数组：\nconst ( _MaxSmallSize = 32768 smallSizeDiv = 8 smallSizeMax = 1024 largeSizeDiv = 128 _NumSizeClasses = 68 _PageShift = 13 ) var class_to_size = [_NumSizeClasses]uint16{0, 8, 16, 24, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768} var class_to_allocnpages = [_NumSizeClasses]uint8{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 3, 2, 3, 1, 3, 2, 3, 4, 5, 6, 1, 7, 6, 5, 4, 3, 5, 7, 2, 9, 7, 5, 8, 3, 10, 7, 4} var class_to_divmagic = [_NumSizeClasses]uint32{0, ^uint32(0)/8 + 1, ^uint32(0)/16 + 1, ^uint32(0)/24 + 1, ^uint32(0)/32 + 1, ^uint32(0)/48 + 1, ^uint32(0)/64 + 1, ^uint32(0)/80 + 1, ^uint32(0)/96 + 1, ^uint32(0)/112 + 1, ^uint32(0)/128 + 1, ^uint32(0)/144 + 1, ^uint32(0)/160 + 1, ^uint32(0)/176 + 1, ^uint32(0)/192 + 1, ^uint32(0)/208 + 1, ^uint32(0)/224 + 1, ^uint32(0)/240 + 1, ^uint32(0)/256 + 1, ^uint32(0)/288 + 1, ^uint32(0)/320 + 1, ^uint32(0)/352 + 1, ^uint32(0)/384 + 1, ^uint32(0)/416 + 1, ^uint32(0)/448 + 1, ^uint32(0)/480 + 1, ^uint32(0)/512 + 1, ^uint32(0)/576 + 1, ^uint32(0)/640 + 1, ^uint32(0)/704 + 1, ^uint32(0)/768 + 1, ^uint32(0)/896 + 1, ^uint32(0)/1024 + 1, ^uint32(0)/1152 + 1, ^uint32(0)/1280 + 1, ^uint32(0)/1408 + 1, ^uint32(0)/1536 + 1, ^uint32(0)/1792 + 1, ^uint32(0)/2048 + 1, ^uint32(0)/2304 + 1, ^uint32(0)/2688 + 1, ^uint32(0)/3072 + 1, ^uint32(0)/3200 + 1, ^uint32(0)/3456 + 1, ^uint32(0)/4096 + 1, ^uint32(0)/4864 + 1, ^uint32(0)/5376 + 1, ^uint32(0)/6144 + 1, ^uint32(0)/6528 + 1, ^uint32(0)/6784 + 1, ^uint32(0)/6912 + 1, ^uint32(0)/8192 + 1, ^uint32(0)/9472 + 1, ^uint32(0)/9728 + 1, ^uint32(0)/10240 + 1, ^uint32(0)/10880 + 1, ^uint32(0)/12288 + 1, ^uint32(0)/13568 + 1, ^uint32(0)/14336 + 1, ^uint32(0)/16384 + 1, ^uint32(0)/18432 + 1, ^uint32(0)/19072 + 1, ^uint32(0)/20480 + 1, ^uint32(0)/21760 + 1, ^uint32(0)/24576 + 1, ^uint32(0)/27264 + 1, ^uint32(0)/28672 + 1, ^uint32(0)/32768 + 1} var size_to_class8 = [smallSizeMax/smallSizeDiv + 1]uint8{0, 1, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32} var size_to_class128 = [(_MaxSmallSize-smallSizeMax)/largeSizeDiv + 1]uint8{32, 33, 34, 35, 36, 37, 37, 38, 38, 39, 39, 40, 40, 40, 41, 41, 41, 42, 43, 43, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 47, 47, 48, 48, 48, 49, 49, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67} 为对象寻找 Span 的流程如下：\n计算对象所需内存大小 size。 根据 size 到 size class 映射，得到 size class。 根据 size class 和对象是否包含指针，得到 span class。 获取该 span class 指向的 span。 以分配一个包含指针，大小为 20Byte 的对象为例，根据映射表， size class 3，它的对象大小范围是 (16, 24]Byte，20Byte 刚好在这之间， 所以此对象的 size class 为 3，size class 到 span class 的计算如下：\ntype spanClass uint8 // noscan 为 false 代表对象包含指针 func makeSpanClass(sizeclass uint8, noscan bool) spanClass { return spanClass(sizeclass\u0026lt;\u0026lt;1) | spanClass(bool2int(noscan)) } 所以对应的 span class 为：\nspan class = 3\u0026lt;\u0026lt;1 | 0 // 即 110 | 000 = 6 所以该对象需要的是 span class 6 指向的 span，自此，小对象内存分配完成。\n源码中三段分别针对 tiny、小、大对象进行分配，下面只详细贴出小对象分配内存的代码：\nif size \u0026lt;= maxSmallSize { if noscan \u0026amp;\u0026amp; size \u0026lt; maxTinySize { // tiny 对象分配 (\u0026lt; 16B) ... } else { // 小对象分配 (16B ~ 32KB) var sizeclass uint8 // 先计算 sizeclass if size \u0026lt;= smallSizeMax-8 { sizeclass = size_to_class8[divRoundUp(size, smallSizeDiv)] } else { sizeclass = size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)] } size = uintptr(class_to_size[sizeclass]) // 再计算 span class spc := makeSpanClass(sizeclass, noscan) // 分配对应的 span (是一个 *mspan) span = c.alloc[spc] v := nextFreeFast(span) if v == 0 { v, span, shouldhelpgc = c.nextFree(spc) } x = unsafe.Pointer(v) if needzero \u0026amp;\u0026amp; span.needzero != 0 { memclrNoHeapPointers(unsafe.Pointer(v), size) } } } else { // 大对象分配 (\u0026gt; 32KB) ... span = c.allocLarge(size, noscan) ... } 大对象（\u0026gt; 32KB）直接在 mheap 上分配，首先计算出需要的内存页数和 span class， 然后优先从 free 中搜索可用的 span，如果没找到，会从 scav 中搜索可用的 span， 如果还没找到，则向 OS 申请内存，再重新搜索两棵树，必然能找到 span。 如果找到的 span 比需要的 span 大，则把 span 分割成 2 个 span， 一个刚好是需求大小，把剩下的 span 再加入到 free 中去。\n// from runtime/mcache.go func (c *mcache) allocLarge(size uintptr, noscan bool) *mspan { if size+_PageSize \u0026lt; size { throw(\u0026#34;out of memory\u0026#34;) } // _PageShift = 13，从这里就能看出一页是 8KB npages := size \u0026gt;\u0026gt; _PageShift if size\u0026amp;_PageMask != 0 { npages++ } // Deduct credit for this span allocation and sweep if // necessary. mHeap_Alloc will also sweep npages, so this only // pays the debt down to npage pages. deductSweepCredit(npages*_PageSize, npages) spc := makeSpanClass(0, noscan) s := mheap_.alloc(npages, spc) if s == nil { throw(\u0026#34;out of memory\u0026#34;) } stats := memstats.heapStats.acquire() atomic.Xadduintptr(\u0026amp;stats.largeAlloc, npages*pageSize) atomic.Xadduintptr(\u0026amp;stats.largeAllocCount, 1) memstats.heapStats.release() // Update heapLive. gcController.update(int64(s.npages*pageSize), 0) // Put the large span in the mcentral swept list so that it\u0026#39;s // visible to the background sweeper. mheap_.central[spc].mcentral.fullSwept(mheap_.sweepgen).push(s) s.limit = s.base() + size heapBitsForAddr(s.base()).initSpan(s) return s } 三、垃圾回收 (一) 标记-清除 (二) 三色可达性分析 (三) gc 触发 (四) gc 过程 gcStart Mark Sweep 参考文献 超干货！彻底搞懂Golang内存管理和垃圾回收 ","permalink":"https://theone-daxia.github.io/blog/code/go/gc/","summary":"前言 网上有很多讲 go gc 的文章，但大多讲的不明不白， 一些突然出现的术语更是不知从何而起，导致看过一些文章后对 gc 依旧云里雾里。 好在最近在公众号看到了一篇文章，我觉得写的很赞， 起码解答了那些突然出现的术语是什么。\n我决定把它搬运到这里，手写一遍记忆更加深刻。 接下来是对原文的默写，忘了就直接抄写。\n原文中会贴出一些 go 的源代码，我本地 go 版本是 1.18.2，对照看的时候会有些出入， 出入的地方我就改贴上我本地的 go 源代码。 所有图片都来源于原文，原文地址在最下面参考文献中列出。 默写加抄写 本文以 go 内存管理为切入点，再到 go 垃圾回收，系统的讲解了 go 自动内存管理系统的设计和原理。\n一、TCMalloc go 的内存管理借鉴了 TCMalloc 的设计思想，TCMalloc 全称 Thread-Caching Malloc， 是 google 开发的内存分配器，为了方便理解 go 的内存管理，有必要先熟悉下 TCMalloc。\n(一) Page 操作系统对内存的管理以页为单位，TCMalloc 也是这样， 只不过 TCMalloc 里的 Page 大小与操作系统里的大小不一定相等，是倍数的关系。\n(二) Span 一组连续的 Page 称为 Span，比如可以有 4 个页大小的 Span，也可以有 8 个页大小的 Span。 Span 比 Page 高一个层级，是为了方便管理一定大小的内存区域， Span 是 TCMalloc 中内存管理的基本单位。","title":"Golang内存管理和垃圾回收"},{"content":"字符串拼接方式 += bytes.Buffer{}.WriteString() strings.Builder{}.WriteString() copy 基准测试 代码：\nvar ( str = \u0026#34;s\u0026#34; count = 1000 expectStr = strings.Repeat(str, count) ) func BenchmarkPlus(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { var s string for j := 0; j \u0026lt; count; j++ { s += str } if expectStr != s { b.Error(\u0026#34;repeat count error\u0026#34;) } } } func BenchmarkBuffer(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { var s bytes.Buffer for j := 0; j \u0026lt; count; j++ { s.WriteString(str) } if expectStr != s.String() { b.Error(\u0026#34;repeat count error\u0026#34;) } } } func BenchmarkBuilder(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { var s strings.Builder for j := 0; j \u0026lt; count; j++ { s.WriteString(str) } if expectStr != s.String() { b.Error(\u0026#34;repeat count error\u0026#34;) } } } func BenchmarkCopy(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { bs := make([]byte, len(str)*count) c := 0 for j := 0; j \u0026lt; count; j++ { c += copy(bs[c:], str) } if expectStr != string(bs) { b.Error(\u0026#34;repeat count error\u0026#34;) } } } 运行命令： go test mm/test -bench=. -benchmem -run=none\n结果：\nBenchmarkPlus-4 10101 119007 ns/op 530276 B/op 999 allocs/op BenchmarkBuffer-4 199851 5407 ns/op 3008 B/op 6 allocs/op BenchmarkBuilder-4 224800 4604 ns/op 3320 B/op 9 allocs/op BenchmarkCopy-4 295381 3525 ns/op 1024 B/op 1 allocs/op 总结 效率从高到低：\ncopy strings.Builder bytes.Buffer += ","permalink":"https://theone-daxia.github.io/blog/code/go/string-join/","summary":"字符串拼接方式 += bytes.Buffer{}.WriteString() strings.Builder{}.WriteString() copy 基准测试 代码：\nvar ( str = \u0026#34;s\u0026#34; count = 1000 expectStr = strings.Repeat(str, count) ) func BenchmarkPlus(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { var s string for j := 0; j \u0026lt; count; j++ { s += str } if expectStr != s { b.Error(\u0026#34;repeat count error\u0026#34;) } } } func BenchmarkBuffer(b *testing.B) { for i := 0; i \u0026lt; b.","title":"go 字符串拼接对比"},{"content":"总结 go 的 Mutex 不支持可重入， 因为它的实现里没有记录哪个 goroutine 拥有这把锁，所以要实现一个可重入的锁， 关键在于要能记录哪个 goroutine 拥有锁，且要记录重入次数。\n要记录拥有锁的 goroutine，有两个方案：\n获取 goroutine id，来记录哪个 goroutine 获取了锁。 由调用方的 goroutine 提供一个 token，来标识它自己。 对于方案一，获取 goroutine id 有两种方式。\n第一种是通过 runtime.Stack() 获取。\nfunc GoId() int64 { var buf [64]byte n := runtime.Stack(buf[:], false) s := strings.TrimPrefix(string(buf[:n]), \u0026#34;goroutine \u0026#34;) idField := strings.Fields(s)[0] id, err := strconv.Atoi(idField) if err != nil { panic(fmt.Sprintf(\u0026#34;cannot get goroutine id: %v\\n\u0026#34;, err)) } return int64(id) } 另一种是通过 hacker 方式获取。此方式大致通过以下三步来获取 goroutine id：\n获取当前 goroutine 的 TLS 对象 从 TLS 对象中获取 goroutine 结构的 g 指针 从 g 指针中取出 goroutine id 由于不同 go 版本的 goroutine 结构不同， 要搞清楚不同版本的 goroutine 结构差异，所涉及内容过于底层且复杂， 所以直接使用第三方库来获取 goroutine id 即可。 这里推荐使用 pertermattis/goid\n代码实现 接下来用方案一来实现一个可重入锁。\npackage recursive_mutex import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/petermattis/goid\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;sync/atomic\u0026#34; ) type RecursiveMutex struct { sync.Mutex owner int64 // 当前持有锁的 goroutine id recursion int32 // 当前持有锁的 goroutine 的重入次数 } func (m *RecursiveMutex) Lock() { gid := goid.Get() if atomic.LoadInt64(\u0026amp;m.owner) == gid { // 当前持有锁的 goroutine 就是本次调用的 goroutine，说明是重入 m.recursion++ return } m.Mutex.Lock() // 获得锁的 goroutine 第一次调用，记下它的 id，调用次数加一 atomic.StoreInt64(\u0026amp;m.owner, gid) m.recursion = 1 } func (m *RecursiveMutex) Unlock() { gid := goid.Get() if atomic.LoadInt64(\u0026amp;m.owner) != gid { // 非当前持有锁的 goroutine 尝试释放锁，panic panic(fmt.Sprintf(\u0026#34;curr %d, not owner %d\\n\u0026#34;, gid, m.owner)) } m.recursion-- if m.recursion \u0026gt; 0 { // 持有锁的 goroutine 还没完全释放，直接返回 return } atomic.StoreInt64(\u0026amp;m.owner, -1) m.Mutex.Unlock() } 第二种提供 token 的实现方式和第一种一样，具体可以查看我的 github 项目 https://github.com/theone-daxia/recursive-mutex\n文献 极客时间-Go并发编程实战课（鸟窝） ","permalink":"https://theone-daxia.github.io/blog/code/go/recursive-mutex/","summary":"总结 go 的 Mutex 不支持可重入， 因为它的实现里没有记录哪个 goroutine 拥有这把锁，所以要实现一个可重入的锁， 关键在于要能记录哪个 goroutine 拥有锁，且要记录重入次数。\n要记录拥有锁的 goroutine，有两个方案：\n获取 goroutine id，来记录哪个 goroutine 获取了锁。 由调用方的 goroutine 提供一个 token，来标识它自己。 对于方案一，获取 goroutine id 有两种方式。\n第一种是通过 runtime.Stack() 获取。\nfunc GoId() int64 { var buf [64]byte n := runtime.Stack(buf[:], false) s := strings.TrimPrefix(string(buf[:n]), \u0026#34;goroutine \u0026#34;) idField := strings.Fields(s)[0] id, err := strconv.Atoi(idField) if err != nil { panic(fmt.Sprintf(\u0026#34;cannot get goroutine id: %v\\n\u0026#34;, err)) } return int64(id) } 另一种是通过 hacker 方式获取。此方式大致通过以下三步来获取 goroutine id：","title":"go实现可重入锁"},{"content":"在查看 Mutex 源码中，看到了 \u0026amp;^ 这个运算符， 没见过，就去查了查。\n含义 按位清零\n即：\n运算符右边数字二进制为1的位置，左边数字二进制对应位置置0 运算符右边数字二进制为0的位置，左边数字二进制对应位置保留 示例 a := 10 b := 2 res := a \u0026amp;^ b fmt.Printf(\u0026#34;a = %b(%d)\\n\u0026#34;, a, a) // a = 1010(10) fmt.Printf(\u0026#34;b = %b(%d)\\n\u0026#34;, b, b) // b = 10(2) fmt.Printf(\u0026#34;res = %b(%d)\\n\u0026#34;, res, res) // res = 1000(8) ","permalink":"https://theone-daxia.github.io/blog/code/go/bit-clear/","summary":"在查看 Mutex 源码中，看到了 \u0026amp;^ 这个运算符， 没见过，就去查了查。\n含义 按位清零\n即：\n运算符右边数字二进制为1的位置，左边数字二进制对应位置置0 运算符右边数字二进制为0的位置，左边数字二进制对应位置保留 示例 a := 10 b := 2 res := a \u0026amp;^ b fmt.Printf(\u0026#34;a = %b(%d)\\n\u0026#34;, a, a) // a = 1010(10) fmt.Printf(\u0026#34;b = %b(%d)\\n\u0026#34;, b, b) // b = 10(2) fmt.Printf(\u0026#34;res = %b(%d)\\n\u0026#34;, res, res) // res = 1000(8) ","title":"\u0026^ 运算符"},{"content":"下面的 MyMutex 即通过原子操作实现了 Locker 接口。\n只是简易实现，实际的 Mutex 还会考虑到给 新来的goroutine、等待的goroutine更多机会， 还有饥饿处理（1ms后），防止队尾的goroutine总是得不到锁。\npackage test import ( \u0026#34;sync\u0026#34; \u0026#34;sync/atomic\u0026#34; \u0026#34;testing\u0026#34; ) type MyMutex struct { key int32 } func (m *MyMutex)Lock() { for !atomic.CompareAndSwapInt32(\u0026amp;m.key, 0, 1) { } } func (m *MyMutex)Unlock() { atomic.StoreInt32(\u0026amp;m.key, 0) } func TestMutex(t *testing.T) { var count = 0 var wg sync.WaitGroup var myMux = MyMutex{} wg.Add(10) for i := 0; i \u0026lt; 10; i++ { go func() { defer wg.Done() for i := 0; i \u0026lt; 10000; i++ { myMux.Lock() count++ myMux.Unlock() } }() } wg.Wait() t.Log(count) } ","permalink":"https://theone-daxia.github.io/blog/code/go/atomic/","summary":"下面的 MyMutex 即通过原子操作实现了 Locker 接口。\n只是简易实现，实际的 Mutex 还会考虑到给 新来的goroutine、等待的goroutine更多机会， 还有饥饿处理（1ms后），防止队尾的goroutine总是得不到锁。\npackage test import ( \u0026#34;sync\u0026#34; \u0026#34;sync/atomic\u0026#34; \u0026#34;testing\u0026#34; ) type MyMutex struct { key int32 } func (m *MyMutex)Lock() { for !atomic.CompareAndSwapInt32(\u0026amp;m.key, 0, 1) { } } func (m *MyMutex)Unlock() { atomic.StoreInt32(\u0026amp;m.key, 0) } func TestMutex(t *testing.T) { var count = 0 var wg sync.WaitGroup var myMux = MyMutex{} wg.Add(10) for i := 0; i \u0026lt; 10; i++ { go func() { defer wg.","title":"原子操作实现互斥锁"},{"content":"数组技巧 前缀和 适用场景\n适用于原始数组不会被修改的情况下，频繁的查询某个区间的累加和。\n构造方式\nnums := []int{1,2,3} preSum := make([]int, len(nums)+1) for i := 1; i \u0026lt; len(nums); i++ { preSum[i] = preSum[i-1] + nums[i-1] } 题目推荐（leetcode）\n303. 区域和检索-数组不可变 304. 二维区域和检索-矩阵不可变 差分数组 适用场景\n适用于频繁对原始数组某个区间的元素进行增减。\n构造方式\nnums := []int{1,2,3,4,5} diff := make([]int, len(nums)) diff[0] = nums[0] for i := 1; i \u0026lt; len(nums); i++ { diff[i] = nums[i] - nums[i-1] } // 如果要对原始数组下标 1-3 区间的元素都加 2，只需做如下两步操作 diff[1] += 2 diff[4] -= 2 // 最后根据 diff 来构造更新后原始数组 res := make([]int, len(diff)) res[0] = diff[0] for i := 1; i \u0026lt; len(diff); i++ { res[i] = res[i-1] + diff[i] } 题目推荐（leetcode）\n1094. 拼车 1109. 航班预订统计 滑动窗口 适用场景\n适用于能回答出以下 3 点问题的子串、子数组问题：\n什么时候扩大窗口？ 什么时候缩小窗口？ 什么时候更新结果？ 代码框架\nleft, right := 0, 0 for right \u0026lt; len(s) { in := s[right] right++ // 扩大窗口 ... // 窗口数据更新 for { out := s[left] left++ // 缩小窗口 ... // 窗口数据更新 } } 题目推荐（leetcode）\n3. 无重复字符的最长子串 76. 最小覆盖子串 209. 长度最小的子数组 219. 存在重复元素 II 220. 存在重复元素 III 395. 至少有 K 个重复字符的最长子串 424. 替换后的最长重复字符 438. 找到字符串中所有字母异位词 567. 字符串的排列 713. 乘积小于K的子数组 862. 和至少为 K 的最短子数组 1004. 最大连续1的个数 III 1438. 绝对差不超过限制的最长连续子数组 动态规划 适用场景\n求最值问题，且具备最优子结构，即能通过子问题的最值得到原问题的最值。\n三要素：最优子结构、重叠子问题、状态转移方程。\n框架\n明确 base case 明确状态（原问题和子问题中会变化的变量） 明确选择（导致状态产生变化的行为） 定义dp数组/函数的含义 自顶向下：会存在一个递归的 dp 函数 自底向上：会存在一个 dp 数组 题目推荐（leetcode）\n322. 零钱兑换 509. 斐波那契数\n回溯算法 适用场景\n排列、组合、子集问题。\n思路：解决一个回溯问题，实际上就是一个决策树的遍历过程，站在决策树的一个节点上，你只需要思考 3 个问题：\n路径：已作出的选择 选择列表：当前可以做的选择 结束条件：到达决策树的底层，无法再做选择的条件 框架\nres := [][]int{} backtrack(路径, 选择列表) { if 满足结束条件 { res = append(res, 路径) } for 选择列表 { 做选择 backtrack(路径, 选择列表) 撤销选择 } } 题目推荐（leetcode）\n46. 全排列 51. N 皇后 77. 组合 78. 子集 ","permalink":"https://theone-daxia.github.io/blog/code/algorithm/thinking/","summary":"数组技巧 前缀和 适用场景\n适用于原始数组不会被修改的情况下，频繁的查询某个区间的累加和。\n构造方式\nnums := []int{1,2,3} preSum := make([]int, len(nums)+1) for i := 1; i \u0026lt; len(nums); i++ { preSum[i] = preSum[i-1] + nums[i-1] } 题目推荐（leetcode）\n303. 区域和检索-数组不可变 304. 二维区域和检索-矩阵不可变 差分数组 适用场景\n适用于频繁对原始数组某个区间的元素进行增减。\n构造方式\nnums := []int{1,2,3,4,5} diff := make([]int, len(nums)) diff[0] = nums[0] for i := 1; i \u0026lt; len(nums); i++ { diff[i] = nums[i] - nums[i-1] } // 如果要对原始数组下标 1-3 区间的元素都加 2，只需做如下两步操作 diff[1] += 2 diff[4] -= 2 // 最后根据 diff 来构造更新后原始数组 res := make([]int, len(diff)) res[0] = diff[0] for i := 1; i \u0026lt; len(diff); i++ { res[i] = res[i-1] + diff[i] } 题目推荐（leetcode）","title":"算法思维框架"},{"content":"项目列表 【星选美次卡】买一赠一M221次卡（限北京）\n【在售价】299元\n毛孔粗大，肤色不均？M22全模式进口光子嫩肤——美白嫩肤界的佼佼者，目前参与内购还可享受买一赠一，快来下单吧！项目原理戳链接了解\n【专享】菲欧曼复合+基础水光/3次/美白 （美次卡限北京）\n【在售价】6000元\n【到手价】3600元\n如果是第一次接触水光，但是又不知道选什么组合和品牌，那么真心推荐从这个组合开始，补水提亮抗衰美白焕肤！重要的是内购价格仅需￥3600！\n【专享】红蓝光祛痘 买1赠1（限北京）\n【在售价】10元\n红蓝光祛痘，强烈安利给大家！蓝光抑菌，红光加速修复，有粉刺闭口痘痘肌的姐妹快快安排吧！项目原理戳链接了解\n【专享】超爆黑钻卡含欧洲之星|AOPT|超皮秒|嗨体等 10选8（限北京）\n【在售价】4665元\n【到手价】2799元\n必Buy Top养肤全套！清洁+水光补水+果酸换肤+紧致皮肤+祛除皱纹+淡斑美白+抗衰嫩肤，10选8，套餐随心搭配，内购价2799，心动不如行动！项目原理戳链接了解\n【专享】小白福利卡含M22|奇致CC光|果酸焕肤等 6选4（限北京）\n【在售价】332元\n【到手价】199元\n改善黑头粉刺，净肤细致毛孔的急救王，熬夜也发光！美肤套卡给你一站式皮肤护理，只需199即可享受4种变美小绝招~ 项目原理戳链接了解\n【专享】CO2剥脱点阵 淡化痘印痘坑（限北京）\n【在售价】399元\n还在为痘坑痘印烦恼？点阵激光妥妥的安排上！专门针对凹陷性痘坑痘印治疗，CO2剥脱点阵，你值得拥有~ 项目原理戳链接了解\n【美次卡】国产除皱单部位祛鱼尾纹眉间纹抬头纹（限北京）\n【在售价】159元\n【美次卡】冰点脱毛 腋下大臂小臂小腿唇毛眉心 6选1（限北京）\n【在售价】39元\n【美次卡】果酸焕肤清洁祛痘改善闭口痤疮痘肌友好（限北京）\n【在售价】69元\n","permalink":"https://theone-daxia.github.io/blog/medical_beauty/project/","summary":"项目列表 【星选美次卡】买一赠一M221次卡（限北京）\n【在售价】299元\n毛孔粗大，肤色不均？M22全模式进口光子嫩肤——美白嫩肤界的佼佼者，目前参与内购还可享受买一赠一，快来下单吧！项目原理戳链接了解\n【专享】菲欧曼复合+基础水光/3次/美白 （美次卡限北京）\n【在售价】6000元\n【到手价】3600元\n如果是第一次接触水光，但是又不知道选什么组合和品牌，那么真心推荐从这个组合开始，补水提亮抗衰美白焕肤！重要的是内购价格仅需￥3600！\n【专享】红蓝光祛痘 买1赠1（限北京）\n【在售价】10元\n红蓝光祛痘，强烈安利给大家！蓝光抑菌，红光加速修复，有粉刺闭口痘痘肌的姐妹快快安排吧！项目原理戳链接了解\n【专享】超爆黑钻卡含欧洲之星|AOPT|超皮秒|嗨体等 10选8（限北京）\n【在售价】4665元\n【到手价】2799元\n必Buy Top养肤全套！清洁+水光补水+果酸换肤+紧致皮肤+祛除皱纹+淡斑美白+抗衰嫩肤，10选8，套餐随心搭配，内购价2799，心动不如行动！项目原理戳链接了解\n【专享】小白福利卡含M22|奇致CC光|果酸焕肤等 6选4（限北京）\n【在售价】332元\n【到手价】199元\n改善黑头粉刺，净肤细致毛孔的急救王，熬夜也发光！美肤套卡给你一站式皮肤护理，只需199即可享受4种变美小绝招~ 项目原理戳链接了解\n【专享】CO2剥脱点阵 淡化痘印痘坑（限北京）\n【在售价】399元\n还在为痘坑痘印烦恼？点阵激光妥妥的安排上！专门针对凹陷性痘坑痘印治疗，CO2剥脱点阵，你值得拥有~ 项目原理戳链接了解\n【美次卡】国产除皱单部位祛鱼尾纹眉间纹抬头纹（限北京）\n【在售价】159元\n【美次卡】冰点脱毛 腋下大臂小臂小腿唇毛眉心 6选1（限北京）\n【在售价】39元\n【美次卡】果酸焕肤清洁祛痘改善闭口痤疮痘肌友好（限北京）\n【在售价】69元","title":"新氧平台医美福利折扣项目"},{"content":" 一片云落入掌心 渺渺万里何处去 只记取离别时的你 仍年少意气 转身过一入天际 愿我如那时的风 拂去尘世俗名轻拥着你 碧落箫声吹尽 沧海一遇却难找寻 前路崇山峻岭不再有你同行 纵使微茫如烟纵有万般思念 流光总将故人搁浅在断简残篇 不成眠 不等谁来证明不必狂歌痛饮 唯盼重相见 归来时一醉明月 这片云不知归期 渺渺万里何处去 只记取离别时的你 仍年少意气 经年过却难忘记 愿我如那时的风 拂去尘世俗名轻拥着你 苍穹箫声吹尽 此生魂梦已逐君去 前路崇山峻岭不再有你同行 纵使微茫如烟纵有万般思念 流光总将古人搁浅在断简残篇 不成眠 不等谁来证明不必狂歌痛饮 唯盼重相见 我如倦鸟归林 纵使微茫如烟纵有万般思念 流光总将故人搁浅在断简残篇 不成眠 不理白驹过隙不信生死有命 唯盼重相见 归来时一醉明月 ","permalink":"https://theone-daxia.github.io/blog/music/doupo_s1/","summary":" 一片云落入掌心 渺渺万里何处去 只记取离别时的你 仍年少意气 转身过一入天际 愿我如那时的风 拂去尘世俗名轻拥着你 碧落箫声吹尽 沧海一遇却难找寻 前路崇山峻岭不再有你同行 纵使微茫如烟纵有万般思念 流光总将故人搁浅在断简残篇 不成眠 不等谁来证明不必狂歌痛饮 唯盼重相见 归来时一醉明月 这片云不知归期 渺渺万里何处去 只记取离别时的你 仍年少意气 经年过却难忘记 愿我如那时的风 拂去尘世俗名轻拥着你 苍穹箫声吹尽 此生魂梦已逐君去 前路崇山峻岭不再有你同行 纵使微茫如烟纵有万般思念 流光总将古人搁浅在断简残篇 不成眠 不等谁来证明不必狂歌痛饮 唯盼重相见 我如倦鸟归林 纵使微茫如烟纵有万般思念 流光总将故人搁浅在断简残篇 不成眠 不理白驹过隙不信生死有命 唯盼重相见 归来时一醉明月 ","title":"从别后"},{"content":" 月光光 照四方 照遍人间水茫茫 风又急 浪又高 妻离子散各一方 山遥遥 水迢迢 会生会死在今朝 心慌慌 意茫茫 天涯明月何皎皎 月光光 照四方 照遍人间水茫茫 风又急 浪又高 妻离子散各一方 山遥遥 水迢迢 会生会死在今朝 心慌慌 意茫茫 天涯明月何皎皎 风一程 雨一程 山河路远不相逢 青鳞快 离愁浓 一梦黄粱太匆匆 江流阔 血流红 白浪滔滔任西东 江湖暗 星河明 轻舟此去不顾停 ","permalink":"https://theone-daxia.github.io/blog/music/chenshixing/","summary":" 月光光 照四方 照遍人间水茫茫 风又急 浪又高 妻离子散各一方 山遥遥 水迢迢 会生会死在今朝 心慌慌 意茫茫 天涯明月何皎皎 月光光 照四方 照遍人间水茫茫 风又急 浪又高 妻离子散各一方 山遥遥 水迢迢 会生会死在今朝 心慌慌 意茫茫 天涯明月何皎皎 风一程 雨一程 山河路远不相逢 青鳞快 离愁浓 一梦黄粱太匆匆 江流阔 血流红 白浪滔滔任西东 江湖暗 星河明 轻舟此去不顾停 ","title":"远行人"},{"content":"什么是 shell shell 就是一个支持输入命令，并显示出命令的输出的东西\n用 go 来写个简单的 shell 并使用它 步骤\n编写代码 build 出二进制文件，并将路径添加到 /etc/shells 里面 更换使用的 shell，退出重进（chsc -s xxx） 完整代码如下\npackage main import ( \u0026#34;bufio\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;strings\u0026#34; ) func main() { reader := bufio.NewReader(os.Stdin) for { fmt.Print(\u0026#34;\u0026gt; \u0026#34;) // Read the keyboad input input, err := reader.ReadString(\u0026#39;\\n\u0026#39;) if err != nil { fmt.Fprintln(os.Stderr, err) } // Handle the execution of the input if err = execInput(input); err != nil { fmt.Fprintln(os.Stderr, err) } } } func execInput(input string) error { // Remove the newline character input = strings.TrimSuffix(input, \u0026#34;\\n\u0026#34;) // Split the input to separate the command and the arguments args := strings.Split(input, \u0026#34; \u0026#34;) switch args[0] { case \u0026#34;cd\u0026#34;: // \u0026#39;cd\u0026#39; to home dir with empty path not yet supported if len(args) \u0026lt; 2 { return errors.New(\u0026#34;path required\u0026#34;) } // Change the directory and return the error return os.Chdir(args[1]) case \u0026#34;exit\u0026#34;: os.Exit(0) } // Pass the program and the arguments separately cmd := exec.Command(args[0], args[1:]...) // Set the correct output device cmd.Stderr = os.Stderr cmd.Stdout = os.Stdout // Execute the command and return the error return cmd.Run() } 吐槽 写的这个 shell 实在是太简单了，要想达到基本满意的程度，还需要做很多很多， 还是老实用 zsh 吧。\n主要还是想不出什么新意，如果为了平时工作方便，shell 里集成一些命令， 通过更简单的方式来提供复杂的功能，可是 alias 也能做到，何必写个 shell 呢 😂\n虽然这个 shell 很简单，但是还是有一点收获， 比如知道了 cd 并不是一个程序，而是 shell 内置的功能。\n为了写出更有趣、更实用的 shell，如果谁有任何想法，欢迎在我的 订阅号 里留言 🔥\n参考文献 Writing a simple shell in Go ","permalink":"https://theone-daxia.github.io/blog/code/shell_in_go/","summary":"什么是 shell shell 就是一个支持输入命令，并显示出命令的输出的东西\n用 go 来写个简单的 shell 并使用它 步骤\n编写代码 build 出二进制文件，并将路径添加到 /etc/shells 里面 更换使用的 shell，退出重进（chsc -s xxx） 完整代码如下\npackage main import ( \u0026#34;bufio\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;strings\u0026#34; ) func main() { reader := bufio.NewReader(os.Stdin) for { fmt.Print(\u0026#34;\u0026gt; \u0026#34;) // Read the keyboad input input, err := reader.ReadString(\u0026#39;\\n\u0026#39;) if err != nil { fmt.Fprintln(os.Stderr, err) } // Handle the execution of the input if err = execInput(input); err !","title":"用 go 写个简单的 shell"},{"content":"这应该是我在北京看过的第三个话剧，前两个叫啥已经记不起来了， 总之，他们给我的感觉都差不多，并没有什么震撼，心里没什么波澜。\n这个话剧整体感觉也是如此，但它有个非常特别的地方， 整个2小时的表演时间，完全只有黄湘丽一个人， 大段的台词，变换的灯光，拿起吉他自弹自唱，甚至还有现场做饭，都在体现它的特别。\n整个话剧的内容，是在讲述一个女生从女孩，到少女，再到母亲， 都只是想让那名男子认识她、认出她、爱她。 想要不顾一切，不求回报的爱，最终却选择平静的死亡。\n佩服这位女演员。\n","permalink":"https://theone-daxia.github.io/blog/drama/letter_from_a_strange_woman/","summary":"这应该是我在北京看过的第三个话剧，前两个叫啥已经记不起来了， 总之，他们给我的感觉都差不多，并没有什么震撼，心里没什么波澜。\n这个话剧整体感觉也是如此，但它有个非常特别的地方， 整个2小时的表演时间，完全只有黄湘丽一个人， 大段的台词，变换的灯光，拿起吉他自弹自唱，甚至还有现场做饭，都在体现它的特别。\n整个话剧的内容，是在讲述一个女生从女孩，到少女，再到母亲， 都只是想让那名男子认识她、认出她、爱她。 想要不顾一切，不求回报的爱，最终却选择平静的死亡。\n佩服这位女演员。","title":"一个陌生女人的来信"},{"content":"位置信息 店名：Miss Mousse 蜜丝慕斯蛋糕（望京悠乐汇店） 地点：望京悠乐汇A4座一层底商136 总结 之前买生日蛋糕，总有些不如意， 要不就是有点好看，但是吃起来不好吃， 要不就是感觉比较小，其实量挺大，两个人根本吃不完。\n这一次的生日我\u0026quot;翻山越岭\u0026quot;，在美团上找到了一家蛋糕店，竟有4寸蛋糕， 不仅量符合我的要求，模样之精美更是出乎我的意料，甚至看了下面的评论， 感觉每一个都味道绝佳。\n于是挑选了一款自认为很有仙气的蛋糕，\u0026ldquo;懵懂的椰子\u0026rdquo;， 拿到蛋糕后，果然没让我失望，好看又好吃， 封面图就是我拍的照片， 赠送了心形的燃烧棒（不知道叫啥，临时瞎起的名字）， 两人份的餐具也是精美可爱。\n是一家值得收藏的蛋糕店了，而且他家还提供座位，周日可以在那看书， 空气中还有一股淡淡的甜香，遗憾没能早点发现它。\n","permalink":"https://theone-daxia.github.io/blog/food/birthday_cake/","summary":"位置信息 店名：Miss Mousse 蜜丝慕斯蛋糕（望京悠乐汇店） 地点：望京悠乐汇A4座一层底商136 总结 之前买生日蛋糕，总有些不如意， 要不就是有点好看，但是吃起来不好吃， 要不就是感觉比较小，其实量挺大，两个人根本吃不完。\n这一次的生日我\u0026quot;翻山越岭\u0026quot;，在美团上找到了一家蛋糕店，竟有4寸蛋糕， 不仅量符合我的要求，模样之精美更是出乎我的意料，甚至看了下面的评论， 感觉每一个都味道绝佳。\n于是挑选了一款自认为很有仙气的蛋糕，\u0026ldquo;懵懂的椰子\u0026rdquo;， 拿到蛋糕后，果然没让我失望，好看又好吃， 封面图就是我拍的照片， 赠送了心形的燃烧棒（不知道叫啥，临时瞎起的名字）， 两人份的餐具也是精美可爱。\n是一家值得收藏的蛋糕店了，而且他家还提供座位，周日可以在那看书， 空气中还有一股淡淡的甜香，遗憾没能早点发现它。","title":"生日蛋糕"},{"content":"当前环境 hugo版本：v0.88.1 markdown 解析器：goldmark（Hugo 从 v0.60.0 开始，markdown 解析器就默认使用 goldmark） 下面介绍配置 KaTeX 步骤\n添加 math partial 创建一个 math partial，路径为：/layouts/partials/math.html\n给 math partial 添加内容 在 /layouts/partials/math.html 文件里添加如下内容（ 参考 Auto-render Extension ）\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css\u0026#34; integrity=\u0026#34;sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js\u0026#34; integrity=\u0026#34;sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; onload=\u0026#34;renderMathInElement(document.body);\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 只添加上述内容的话，就会只支持 block 公式，为了支持 inline 公式，还要在下方加入如下内容\n\u0026lt;script\u0026gt; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { renderMathInElement(document.body, { // customised options // • auto-render specific keys, e.g.: delimiters: [ {left: \u0026#39;$$\u0026#39;, right: \u0026#39;$$\u0026#39;, display: true}, {left: \u0026#39;$\u0026#39;, right: \u0026#39;$\u0026#39;, display: false}, {left: \u0026#39;\\\\(\u0026#39;, right: \u0026#39;\\\\)\u0026#39;, display: false}, {left: \u0026#39;\\\\[\u0026#39;, right: \u0026#39;\\\\]\u0026#39;, display: true} ], // • rendering keys, e.g.: throwOnError : false }); }); \u0026lt;/script\u0026gt; 将 math partial 引入到模板里 由于我使用的是 papermod 主题，已经提供了 extend_head.html 用以添加自定义的扩展代码， 所以在 extend_head.html 文件里添加如下内容\n{{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} 定义 math 参数 全站生效：可在 config.yml 文件里，添加 math 参数 math: true 只在某片文章里生效：可在文章的 front-matter 里添加参数 math: true 示例 对于这个例子：$\\sum_i^nd_i$，下面给出两种展示效果：\ninline：$\\sum_i^nd_i$ block：$$\\sum_i^nd_i$$ 参考文章 Math Typesetting INLINE MATH WITH KATEX ","permalink":"https://theone-daxia.github.io/blog/code/math_typesetting/","summary":"当前环境 hugo版本：v0.88.1 markdown 解析器：goldmark（Hugo 从 v0.60.0 开始，markdown 解析器就默认使用 goldmark） 下面介绍配置 KaTeX 步骤\n添加 math partial 创建一个 math partial，路径为：/layouts/partials/math.html\n给 math partial 添加内容 在 /layouts/partials/math.html 文件里添加如下内容（ 参考 Auto-render Extension ）\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css\u0026#34; integrity=\u0026#34;sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js\u0026#34; integrity=\u0026#34;sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; onload=\u0026#34;renderMathInElement(document.body);\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 只添加上述内容的话，就会只支持 block 公式，为了支持 inline 公式，还要在下方加入如下内容\n\u0026lt;script\u0026gt; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { renderMathInElement(document.body, { // customised options // • auto-render specific keys, e.g.: delimiters: [ {left: \u0026#39;$$\u0026#39;, right: \u0026#39;$$\u0026#39;, display: true}, {left: \u0026#39;$\u0026#39;, right: \u0026#39;$\u0026#39;, display: false}, {left: \u0026#39;\\\\(\u0026#39;, right: \u0026#39;\\\\)\u0026#39;, display: false}, {left: \u0026#39;\\\\[\u0026#39;, right: \u0026#39;\\\\]\u0026#39;, display: true} ], // • rendering keys, e.","title":"hugo支持数学公式排版"},{"content":"缘起 发现最近总是便秘，两三天都不\u0026quot;上大号\u0026quot;，今早起床突然意识到可能是我一直喝胎菊茶造成的。 一查，果然！\n看下面的功效及副作用可知，适量喝可促进消化，预防便秘，但是喝多了，则会出现反效果，还容易损伤脾胃，出现食欲减退的情况。\n这完美的解释了为啥刚开始喝的时候，记得还是作息饮食规律，每天早上都\u0026quot;大号排毒\u0026quot;，最近却经常便秘，且不见好转，吃健胃消食片也没多大用。 不过怎样才算\u0026quot;喝多了\u0026quot;，以我的情况来看，每天 8～10 朵，不断冲泡，喝上 6～8 杯，连续喝 3～4 个月，就算喝多了。\n简介 胎菊又称甘菊、小胎黄、小白菊，古时曾作贡品，是杭白菊中最上品的一种。 在杭白菊花朵未完全张开的时候摘下来，经干燥加工制成。\n胎菊，性微寒，味辛甘苦，能疏散风热、平肝明目、清热解毒。 用胎菊泡茶，味纯正，浓烈，色泽金黄，含有花蜜的清香，泡久了也不会散开。\n功效 1. 明目 胎菊具有很好的护眼、明目的作用，特别适合上班族等长时间面对电脑的人群。\n2. 补肝、清肝 胎菊具有清热解毒的作用，还能增强身体的抵抗力，预防冠心病等。 胎菊和冰糖一起浸泡，还能起到抗菌作用。\n3. 祛除湿气 一般而言，体内湿气过重的症状表现为口干舌燥、眼睛干涩、上火等，此时可泡一杯胎菊茶来缓解。\n4. 缓解便秘 胎菊花富含丹宁，这种物质能有效促进肠胃蠕动，很好的增强身体的消化能力和食欲，让便秘得到缓解。\n副作用 虽然胎菊有保健的功效，但如果长期服用也不好，会引起身体不适。\n1. 腹痛腹泻 胎菊可以促进消化，但喝多了则会出现反效果，导致肠胃出现寒凉之气，出现腹痛腹泻的现象。\n2. 上火 胎菊性微寒，阴虚火热体质的人喝多了会引起上火现象。\n3. 脾胃受损，食欲减退 喝多了胎菊容易引起胃部不适，导致反酸，肠胃分泌液不正常，可能引起食欲减退的情况。因此脾胃虚寒的人更加不能多喝胎菊，容易损伤脾胃。\n","permalink":"https://theone-daxia.github.io/blog/tea/taiju/","summary":"缘起 发现最近总是便秘，两三天都不\u0026quot;上大号\u0026quot;，今早起床突然意识到可能是我一直喝胎菊茶造成的。 一查，果然！\n看下面的功效及副作用可知，适量喝可促进消化，预防便秘，但是喝多了，则会出现反效果，还容易损伤脾胃，出现食欲减退的情况。\n这完美的解释了为啥刚开始喝的时候，记得还是作息饮食规律，每天早上都\u0026quot;大号排毒\u0026quot;，最近却经常便秘，且不见好转，吃健胃消食片也没多大用。 不过怎样才算\u0026quot;喝多了\u0026quot;，以我的情况来看，每天 8～10 朵，不断冲泡，喝上 6～8 杯，连续喝 3～4 个月，就算喝多了。\n简介 胎菊又称甘菊、小胎黄、小白菊，古时曾作贡品，是杭白菊中最上品的一种。 在杭白菊花朵未完全张开的时候摘下来，经干燥加工制成。\n胎菊，性微寒，味辛甘苦，能疏散风热、平肝明目、清热解毒。 用胎菊泡茶，味纯正，浓烈，色泽金黄，含有花蜜的清香，泡久了也不会散开。\n功效 1. 明目 胎菊具有很好的护眼、明目的作用，特别适合上班族等长时间面对电脑的人群。\n2. 补肝、清肝 胎菊具有清热解毒的作用，还能增强身体的抵抗力，预防冠心病等。 胎菊和冰糖一起浸泡，还能起到抗菌作用。\n3. 祛除湿气 一般而言，体内湿气过重的症状表现为口干舌燥、眼睛干涩、上火等，此时可泡一杯胎菊茶来缓解。\n4. 缓解便秘 胎菊花富含丹宁，这种物质能有效促进肠胃蠕动，很好的增强身体的消化能力和食欲，让便秘得到缓解。\n副作用 虽然胎菊有保健的功效，但如果长期服用也不好，会引起身体不适。\n1. 腹痛腹泻 胎菊可以促进消化，但喝多了则会出现反效果，导致肠胃出现寒凉之气，出现腹痛腹泻的现象。\n2. 上火 胎菊性微寒，阴虚火热体质的人喝多了会引起上火现象。\n3. 脾胃受损，食欲减退 喝多了胎菊容易引起胃部不适，导致反酸，肠胃分泌液不正常，可能引起食欲减退的情况。因此脾胃虚寒的人更加不能多喝胎菊，容易损伤脾胃。","title":"胎菊"},{"content":"简介 SSH 除了登陆服务器，还有一大用途，就是作为加密通信的中介，充当两台服务器之间的加密跳板，使得原本不加密的通信变成加密通信。 这个功能成为端口转发（port forwarding），又称 SSH 隧道（tunnel）。\n端口转发有两个主要作用：\n将不加密的数据放在 SSH 安全连接里传输，使原本不安全的网络服务增加了安全性，比如通过端口转发访问 Telnet、FTP 等明文服务，数据传输就都会加密。 作为数据通信的加密跳板，绕过网络防火墙。 三种使用方法 端口转发有三种使用方法：动态转发、本地转发、远程转发。\n1. 动态转发 动态转发是指，本机与 SSH 服务器之间创建了一个加密连接，本机内部针对某个端口的通信，都通过这个加密连接转发。\n动态转发将一个本地端口绑定到了 SSH 服务器，而 目标地址:目标端口 是不固定的，完全由发起的请求决定，所以叫动态转发。\nssh -D local-port tunnel-host -N 上面命令中，-D表示动态转发，local-port是本地端口，tunnel-host是 SSH 服务器， -N表示这个 SSH 连接只进行端口转发，不登录远程 Shell，不能执行远程命令，只能充当隧道。\n如果经常使用动态转发，可以将设置写入 SSH 客户端的个人配置文件（~/.ssh/config）\nDynamicForward tunnel-host:local-port 应用举例 例1：\n远程云主机B1运行了多个服务，分别使用了不同端口，本地主机A1需要访问这些服务。 一方面，由于安全限制，本地主机A1并不能直接访问远程云主机B1上的服务，因此需要进行端口转发， 另一方面，为每个端口分别创建本地端口转发非常麻烦。\n可通过动态端口转发，将A1发起的请求转发到B1，命令如下：\nssh -D localhost:8080 root@xxx.xxx.xxx.xxx -N 注意，这种转发采用了 SOCKS5 协议，访问网站时，需要把 HTTP 请求转成 SOCKS5 协议，才能把本地端口的请求转发出去。 下面是 SSH 隧道建立后的一个使用示例：\ncurl -x socks5://localhost:8080 https://www.google.com 上面命令中，curl 的-x参数指定代理服务器，即通过 SOCKS5 协议的本地 8080 端口，访问https://www.google.com。\n2. 本地转发 本地转发是在本地服务器的 SSH 客户端建立的转发规则。\n本地转发会指定一个本地端口，所有发向那个端口的请求，都会转发到 SSH 跳板机（tunnel-host）， 然后 SSH 跳板机作为中介，将收到的请求发到目标服务器（target-host）的目标端口（target-port）。\nssh -L local-port:target-host:target-port tunnel-host 上面命令中，-L参数表示本地转发，local-port是本地端口， target-host是你想要访问的目标服务器，target-port是目标服务器的端口， tunnel-host是 SSH 跳板机。\n如果经常使用本地转发，可以将设置写入 SSH 客户端的用户个人配置文件（~/.ssh/config）\nHost test.example.com LocalForward client-IP:client-port server-IP:server-port 应用举例 例1：\n有一台阿里云 ECS，安全组默认只允许了 22 端口的访问， 如果上面有一个运行中的服务绑定了 8080 端口，想要临时访问一下该服务的话，该怎么办呢？还得先 这样就比较麻烦，\n一种办法是，先配置安全组，然后进行访问，但这样比较麻烦，还得登后台添加配置。\n另一种就是利用本地转发，非常方便，可以在本地机器运行如下命令：\nssh -L 3000:localhost:8080 ecs-host 上面命令中，ecs-host为 ECS 的地址（比如用户名加公网ip：root@xxx.xxx.xxx.xxx）， 这样就可以通过访问本地的 3000 端口，来请求 ECS 上 8080 端口的服务了。\n3. 远程转发 远程转发是在远程 SSH 服务器建立的转发规则。\n它跟本地转发正好反过来。建立本地到远程服务器的 SSH 隧道以后， 本地转发是通过本地服务器访问远程服务器， 远程转发是通过远程服务器访问本地服务器。 命令格式如下：\nssh -R remote-port:target-host:targer-port -N remote-host 上面命令中，-R表示远程端口转发，remote-port是远程服务器的端口， target-host和target-port是目标服务器及其端口， remote-host是远程服务器。\n如果经常使用远程端口转发，可以将设置写入 SSH 客户端的用户个人配置文件（~/.ssh/config）\nHost remote-forward HostName test.example.com RemoteForward remote-port target-host:target-port 应用举例 例1：\n内网某台服务器 localhost 在 80 端口开了一个服务，可以通过远程转发将这个 80 端口， 映射到具有公网 IP 地址的 public.server 服务器的 8080 端口， 使得访问 public.server:8080 这个地址，就可以访问到那台内网服务器的 80 端口。\nssh -R 8080:localhost:80 -N public.server 例2：\n本地服务器 local 在外网，SSH 跳板机和目标服务器 private.server 都在内网，必须通过 SSH 跳板机才能访问目标服务器。 但是本地服务器 local 无法访问内网中的 SSH 跳板机，而 SSH 跳板机可以访问本地服务器。 由于本机无法访问内网 SSH 跳板机，就无法从外网发起 SSH 隧道，建立端口转发。 得反着来，从 SSH 跳板机发起隧道，建立端口转发，这就形成了远程端口转发。 跳板机执行如下命令，绑定本地服务器 local 的 2121 端口，去访问 private.server:80。\nssh -R 2121:private.server:80 -N local 显然，远程转发要求本地计算机 local 也安装了 SSH 服务器，这样才能接受 SSH 跳板机的远程登录。\n例3：\n家里有台服务器 local，连着家里的 wifi，公司有台处在内网中的服务器 private.server， local 和 private.server 互相都访问不了，但它们都能访问外网。 这时想用家里的服务器 local 访问 private.server:80，该怎么办？\n可以在外网找一个它们都能访问到的服务器，比如还是那台阿里云 ECS（这台 ECS 不能访问 local 和 private.server）， 在 local 上建立 local -\u0026gt; ECS 的本地转发，然后在 private.server 上建立 private.server -\u0026gt; ECS 的远程转发， 这样在 local 访问 localhost:80 就能访问到 private.server 的 80 端口了。\n这也就是所谓的内网穿透。不过涉及公司财产安全，大家不要这样 作死 尝试，因为可能遇到下述情况：\n一哥们穿透内网，被黑客利用，导致内网多台机器数据丢失，被黑客敲诈勒索。\n碰上这种事情，该怎么哭？乖乖申请公司的 VPN 它不香么？\n参考文献 SSH教程 - 网道\n","permalink":"https://theone-daxia.github.io/blog/code/ssh_tunnel/","summary":"简介 SSH 除了登陆服务器，还有一大用途，就是作为加密通信的中介，充当两台服务器之间的加密跳板，使得原本不加密的通信变成加密通信。 这个功能成为端口转发（port forwarding），又称 SSH 隧道（tunnel）。\n端口转发有两个主要作用：\n将不加密的数据放在 SSH 安全连接里传输，使原本不安全的网络服务增加了安全性，比如通过端口转发访问 Telnet、FTP 等明文服务，数据传输就都会加密。 作为数据通信的加密跳板，绕过网络防火墙。 三种使用方法 端口转发有三种使用方法：动态转发、本地转发、远程转发。\n1. 动态转发 动态转发是指，本机与 SSH 服务器之间创建了一个加密连接，本机内部针对某个端口的通信，都通过这个加密连接转发。\n动态转发将一个本地端口绑定到了 SSH 服务器，而 目标地址:目标端口 是不固定的，完全由发起的请求决定，所以叫动态转发。\nssh -D local-port tunnel-host -N 上面命令中，-D表示动态转发，local-port是本地端口，tunnel-host是 SSH 服务器， -N表示这个 SSH 连接只进行端口转发，不登录远程 Shell，不能执行远程命令，只能充当隧道。\n如果经常使用动态转发，可以将设置写入 SSH 客户端的个人配置文件（~/.ssh/config）\nDynamicForward tunnel-host:local-port 应用举例 例1：\n远程云主机B1运行了多个服务，分别使用了不同端口，本地主机A1需要访问这些服务。 一方面，由于安全限制，本地主机A1并不能直接访问远程云主机B1上的服务，因此需要进行端口转发， 另一方面，为每个端口分别创建本地端口转发非常麻烦。\n可通过动态端口转发，将A1发起的请求转发到B1，命令如下：\nssh -D localhost:8080 root@xxx.xxx.xxx.xxx -N 注意，这种转发采用了 SOCKS5 协议，访问网站时，需要把 HTTP 请求转成 SOCKS5 协议，才能把本地端口的请求转发出去。 下面是 SSH 隧道建立后的一个使用示例：\ncurl -x socks5://localhost:8080 https://www.google.com 上面命令中，curl 的-x参数指定代理服务器，即通过 SOCKS5 协议的本地 8080 端口，访问https://www.","title":"SSH 端口转发"},{"content":"目标 使用 GithubPages、Hugo 创建个人博客网站\n功能 正常博客写作 文章支持评论 网站数据分析 准备工作 拥有一个 github 账号 安装 hugo（ Hugo文档 ） 步骤 github 创建两个仓库 一个源码仓库，设置权限为 Private（用于对网站进行任何更改操作） 一个博客仓库，设置权限为 Public（用于对外展示，项目名称为：xxx.github.io，xxx为账户名称） 初始化源码项目 使用 hugo 生成网站 hugo new site quickstart 选择并添加一款心仪主题（ 主题选择 ） # 此处以 Base16 主题为例 cd quickstart/themes git submodule add https://github.com/htdvisser/hugo-base16-theme.git base16 添加博客内容 hugo new blogs/my-first-blog.md 编辑配置文件 config.toml，配置主题及菜单 # 将下面内容添加进 config.toml（不包括本行） theme = \u0026#34;base16\u0026#34; [menu] [[menu.main]] name = \u0026#34;首页\u0026#34; url = \u0026#34;/\u0026#34; weight = 1 [[menu.main]] name = \u0026#34;博客\u0026#34; url = \u0026#34;/blog/\u0026#34; weight = 2 将 quickstart 目录里的内容 push 到源码项目，完成项目初始化 配置 CI/CD 可采用 hugo -D 来生成静态页面，然后同步到公开的博客仓库。 这样做不仅麻烦，也不符合极客精神，所以采用 GithubActions 来自动集成部署。\n配置步骤：\n源码项目根目录下，添加 .github/workflows 文件夹\n在刚创建的文件夹下创建 gh-pages.yml 文件（文件名随便写），写入如下代码\nname: github pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: external_repository: xxx/xxx.github.io\t# 发布到哪个repo deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} publish_dir: ./public\t# 注意这里指的是要发布哪个文件夹的内容，而不是指发布到目的仓库的什么位置，因为hugo默认生成静态网页到public文件夹，所以这里发布public文件夹里的内容 publish_branch: main\t# 发布到哪个branch 注： 此处的 ACTIONS_DEPLOY_KEY 需要在源码仓库中配置，具体步骤如下\n生成一对新的 SSH Key ssh-keygen -t rsa\n将 Public Key 添加到 xxx.github.io 仓库，setting -\u0026gt; Deploy Keys，变量名随便起，勾选 Allow write access。\n将 Private Key 添加到源码仓库，setting -\u0026gt; Secrets，变量名取 ACTIONS_DEPLOY_KEY\n另： Github Actions 的三种实现方案\ngithub_token\ndeploy_key\npersonal_token\ngithub_token 适合 源码 和 public/ 存放在同一个仓库下的不同分支（比如源码在 main，public/ 内容在 gh-pages），指定部署到 gh-pages 分支即可。\ndeploy_key 适合 源码 和 public/ 存放在不同仓库下的模式（此为本文选择的方式）。\n添加附加功能 文章支持评论 可选择 disqus、utteranc，由于 disqus 比较麻烦，得注册账号，好像还收费？所以选择 utteranc。\nutteranc 是一个免费的 GithubApp，可以在 Github 的 Marketplace 中获取，具体操作不再赘述。 下载后绑定到公开的博客仓库，然后在 layouts/partials/article.html 的合适位置添加如下代码\n{{ if .Site.Params.utteranc.enable }} \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;{{ .Site.Params.utteranc.repo }}\u0026#34; issue-term=\u0026#34;{{ .Site.Params.utteranc.issueTerm }}\u0026#34; theme=\u0026#34;{{ .Site.Params.utteranc.theme }}\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; {{ end }} 在 config.toml 中添加如下配置\n[params.utteranc] enable = false repo = \u0026#34;xxx/xxx.github.io\u0026#34; issueTerm = \u0026#34;title\u0026#34; theme = \u0026#34;github-light\u0026#34; 由于最终显示效果不理想\n个人感觉不好看，跟主题风格不搭 评论区域加载速度慢，进入文章几秒后才会出现 个人也不打算在博客文章里跟人交流 故将 utteranc.enable 置为 false，想启用的时候再说。\n添加谷歌分析 谷歌分析是由Google提供的个人免费的网站流量统计服务，支持查看实时流量，分析功能强大。网页和移动端均可查看（需要有vpn）\n使用步骤：\n登陆谷歌分析（ 登陆地址 ），创建账号及媒体资源\n在创建的媒体资源里，添加数据流（选择网站）\n网站网址：填写博客仓库地址，即 xxx.github.io 数据流名称：自己命名 复制数据流的衡量ID（G-xxx），并将其添加进源码项目的 config.toml 中\ngoogleAnalytics = \u0026#34;G-xxx\u0026#34; 复制 themes/base16/layouts/partials/header.html 到 layouts/partials/header.html，然后在复制出来的 header.html 的 head 标签中添加如下代码\n\u0026lt;!-- 添加谷歌分析插件 Google Analytics --\u0026gt; {{ template \u0026#34;_internal/google_analytics.html\u0026#34; . }} 注：该 template 为 Hugo 附带的一个内部模板\n如果不采用内部模板的写法，还可以将创建数据流时，提示的分析代码添加进 head 标签中，不过这种方法明显没有内部模板的方式优雅\n\u0026lt;!-- Global site tag (gtag.js) - Google Analytics --\u0026gt; \u0026lt;script async src=\u0026#34;https://www.googletagmanager.com/gtag/js?id=G-xxx\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag(\u0026#39;js\u0026#39;, new Date()); gtag(\u0026#39;config\u0026#39;, \u0026#39;G-xxx\u0026#39;); \u0026lt;/script\u0026gt; 推到源码项目并自动部署后，访问博客，即可在谷歌分析的实时数据中看到统计信息\n添加卜蒜子 卜蒜子 是一个静态页面计数服务，可显示 page_uv、page_pv、site_uv、site_pv 等数据（ 卜蒜子文档 ）。这里利用它给文章加上 page_uv。\n步骤：\n在 layouts/partials/header.html 的 head 标签中添加如下代码\n\u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 在 layouts/partials/article.html 的 Title 下面添加如下代码\n{{ if .Site.Params.busuanzi.enable }} \u0026lt;div style=\u0026#34;padding: 0 0 1em 0\u0026#34;\u0026gt; \u0026lt;span id=\u0026#34;busuanzi_container_page_pv\u0026#34;\u0026gt; \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; width=\u0026#34;19\u0026#34; height=\u0026#34;14\u0026#34; viewBox=\u0026#34;0 0 20 20\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;2\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34; class=\u0026#34;feather feather-eye\u0026#34;\u0026gt;\u0026lt;path d=\u0026#34;M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z\u0026#34;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;circle cx=\u0026#34;12\u0026#34; cy=\u0026#34;12\u0026#34; r=\u0026#34;3\u0026#34;\u0026gt;\u0026lt;/circle\u0026gt;\u0026lt;/svg\u0026gt; \u0026lt;span id=\u0026#34;busuanzi_value_page_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; {{ end }} 注：这个小眼睛的 svg 文件，是从 这里 下载的，感觉很好用。\n在 config.toml 中添加如下配置\n[params.busuanzi] enable = true 推到源码项目并自动部署后，访问博客，即可在文章的标题下看到统计信息\n","permalink":"https://theone-daxia.github.io/blog/code/hugo_blog_site_record/","summary":"目标 使用 GithubPages、Hugo 创建个人博客网站\n功能 正常博客写作 文章支持评论 网站数据分析 准备工作 拥有一个 github 账号 安装 hugo（ Hugo文档 ） 步骤 github 创建两个仓库 一个源码仓库，设置权限为 Private（用于对网站进行任何更改操作） 一个博客仓库，设置权限为 Public（用于对外展示，项目名称为：xxx.github.io，xxx为账户名称） 初始化源码项目 使用 hugo 生成网站 hugo new site quickstart 选择并添加一款心仪主题（ 主题选择 ） # 此处以 Base16 主题为例 cd quickstart/themes git submodule add https://github.com/htdvisser/hugo-base16-theme.git base16 添加博客内容 hugo new blogs/my-first-blog.md 编辑配置文件 config.toml，配置主题及菜单 # 将下面内容添加进 config.toml（不包括本行） theme = \u0026#34;base16\u0026#34; [menu] [[menu.main]] name = \u0026#34;首页\u0026#34; url = \u0026#34;/\u0026#34; weight = 1 [[menu.main]] name = \u0026#34;博客\u0026#34; url = \u0026#34;/blog/\u0026#34; weight = 2 将 quickstart 目录里的内容 push 到源码项目，完成项目初始化 配置 CI/CD 可采用 hugo -D 来生成静态页面，然后同步到公开的博客仓库。 这样做不仅麻烦，也不符合极客精神，所以采用 GithubActions 来自动集成部署。","title":"利用Hugo搭建静态博客网站记录"},{"content":"NRV 计算 在购买预包装食物时，对是否购买？每天该吃多少？等问题，可通过下面的计算进行快速决策 NRV 计算地址\n营养素参考值 ","permalink":"https://theone-daxia.github.io/blog/health/nrv/","summary":"NRV 计算 在购买预包装食物时，对是否购买？每天该吃多少？等问题，可通过下面的计算进行快速决策 NRV 计算地址\n营养素参考值 ","title":"营养素参考值"},{"content":"微信订阅号 ","permalink":"https://theone-daxia.github.io/follow_me/","summary":"微信订阅号 ","title":""}]