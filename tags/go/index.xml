<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>go &amp;^ on 冲和</title>
    <link>https://theone-daxia.github.io/tags/go/</link>
    <description>Recent content in go &amp;^ on 冲和</description>
    <image>
      <url>https://theone-daxia.github.io/papermod-cover.png</url>
      <link>https://theone-daxia.github.io/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 16 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://theone-daxia.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>&amp;^ 运算符</title>
      <link>https://theone-daxia.github.io/blog/code/go/bit-clear/</link>
      <pubDate>Wed, 16 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://theone-daxia.github.io/blog/code/go/bit-clear/</guid>
      <description>在查看 Mutex 源码中，看到了 &amp;amp;^ 这个运算符， 没见过，就去查了查。
含义 按位清零
即：
运算符右边数字二进制为1的位置，左边数字二进制对应位置置0 运算符右边数字二进制为0的位置，左边数字二进制对应位置保留 示例 a := 10 b := 2 res := a &amp;amp;^ b fmt.Printf(&amp;#34;a = %b(%d)\n&amp;#34;, a, a) // a = 1010(10) fmt.Printf(&amp;#34;b = %b(%d)\n&amp;#34;, b, b) // b = 10(2) fmt.Printf(&amp;#34;res = %b(%d)\n&amp;#34;, res, res) // res = 1000(8) </description>
    </item>
    
    <item>
      <title>用 go 写个简单的 shell</title>
      <link>https://theone-daxia.github.io/blog/code/shell_in_go/</link>
      <pubDate>Wed, 19 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://theone-daxia.github.io/blog/code/shell_in_go/</guid>
      <description>什么是 shell shell 就是一个支持输入命令，并显示出命令的输出的东西
用 go 来写个简单的 shell 并使用它 步骤
编写代码 build 出二进制文件，并将路径添加到 /etc/shells 里面 更换使用的 shell，退出重进（chsc -s xxx） 完整代码如下
package main import ( &amp;#34;bufio&amp;#34; &amp;#34;errors&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;os/exec&amp;#34; &amp;#34;strings&amp;#34; ) func main() { reader := bufio.NewReader(os.Stdin) for { fmt.Print(&amp;#34;&amp;gt; &amp;#34;) // Read the keyboad input input, err := reader.ReadString(&amp;#39;\n&amp;#39;) if err != nil { fmt.Fprintln(os.Stderr, err) } // Handle the execution of the input if err = execInput(input); err !</description>
    </item>
    
  </channel>
</rss>
